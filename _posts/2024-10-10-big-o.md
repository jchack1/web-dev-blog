---
layout: post
title: "Revisiting Data Structures and Algorithms - Big O Notation"
date: 2024-10-10 17:30
tags: computer-science data-structures
navigation: true
class: post-template
current: post
published: false
---

I am learning about data structures and algorithms again.

A while ago I wanted to try Leetcode to get better at solving code problems. It was good practice, but I found that if I picked random problems to work on, I could usually come with a solution, but the problems sometimes are testing your knowledge of specific algorithms. How am I supposed to get the "correct" answer if I have never studied the algorithm? I don't want to just google the answer to every question, this defeats the whole purpose.

I figured I should try learning more algorithms, and once I learn them, <em>then</em> I should practice them.

This time around for data structures and algorithms, I found a course that teaches this topic for JavaScript. The first lesson is on Big O Notation.

This course is the JavaScript Algorithms and Data Structures Masterclass.

I generally understand the concepts behind Big O, but I sometimes struggle to analyze the time and space complexity for different solutions to a problem.

### Counting operations

The idea here is that to analyze a solution, you need to have a general idea of how much time (or space) it is taking. Going through the code, you <strong>count all of the operations and assignments</strong> that are taking place.

You don't need the most accurate tally. It's about noticing general trends. Let's say your function takes an argument `n`, a number. If you notice that your code often does something `n` times, it will take longer to complete as the value of `n` grows.
