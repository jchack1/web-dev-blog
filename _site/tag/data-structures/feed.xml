<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="https://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="http://localhost:4000/tag/data-structures/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2023-08-10T20:00:06-06:00</updated>
  <id>http://localhost:4000/tag/data-structures/feed.xml</id>

  
  
  

  
    <title type="html">Julia Hack | </title>
  

  
    <subtitle>Web development blog</subtitle>
  

  

  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">Implementing hash tables in JavaScript</title>
      <link href="http://localhost:4000/hash-tables-javascript" rel="alternate" type="text/html" title="Implementing hash tables in JavaScript" />
      <published>2023-08-10T15:30:00-06:00</published>
      <updated>2023-08-10T15:30:00-06:00</updated>
      <id>http://localhost:4000/hash-tables-javascript</id>
      <content type="html" xml:base="http://localhost:4000/hash-tables-javascript">&lt;p&gt;Hash tables are a commonly used data structure and, apparently, are commonly asked about in interviews.&lt;/p&gt;

&lt;p&gt;Hash tables store data in key-value pairs. They should be used when you are looking for very quick look-ups. Generally, if you search a hash table for a particular key, it should be able to find it for you without having to search the entire data structure, giving look-ups O(1) time.&lt;/p&gt;

&lt;p&gt;Inserting and deleting should also be O(1) time. They take up O(n) space.&lt;/p&gt;

&lt;p&gt;Here are a couple links that were helpful for me to learn about hash tables in JavaScript:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.freecodecamp.org/news/javascript-hash-table-associative-array-hashing-in-js/&quot;&gt;this freeCodeCamp article&lt;/a&gt; for a good overview and a look into a simple JavaScript implementation&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.educative.io/blog/data-strucutres-hash-table-javascript&quot;&gt;this educative article&lt;/a&gt; for learning more about collisions, and generally a good overview&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=F95z5Wxd9ks&amp;amp;t=459s&quot;&gt;this freeCodeCamp video&lt;/a&gt; for another explanation and JavaScript implementation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In day-to-day coding with JavaScript, you shouldn’t need to implement hash tables yourself, as we have &lt;code class=&quot;highlighter-rouge&quot;&gt;Objects&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Maps&lt;/code&gt; that do this for us. The freeCodeCamp article above explains some of the drawbacks of objects, and where maps have made improvements.&lt;/p&gt;

&lt;p&gt;Essentially, object methods (inherited from the Object prototype) can be easily overwritten by mistake. Maps require you to use built-in &lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt; methods when working with the map, and inherited methods can’t be overwritten.&lt;/p&gt;

&lt;h3 id=&quot;implementing-hash-tables-ourselves&quot;&gt;Implementing hash tables ourselves&lt;/h3&gt;

&lt;p&gt;There are many ways you could do this, but with the help of the above resources I came up with an implementation I like. Creating a HashTable class made the most sense to me.&lt;/p&gt;

&lt;p&gt;Behind the scenes, a hash table is just an array of arrays. You determine the size of the array when you initially create the hashtable. I like to make this size dynamic instead of hardcoded. You could probably change the size if you wanted to later on, but this seemed simpler for now.&lt;/p&gt;

&lt;p&gt;Here is the constructor inside the HashTable class:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;numBuckets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;numBuckets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Of course, you’d create a new hash table like so:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hashtable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HashTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//where 5 is size of array&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next we need a hash function. This takes the key of the item you are adding, and converts it into a number. This number is an index in the hash table array. The way we did this here, based off the examples in the resources above, is by calculating a number based on the character codes in the key. Each character is assigned to a numeric code. We sum these values and use the modulo &lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt; operator to ensure our hash isn’t larger than the length of the array.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;_hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;charCodeAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We use the hash function everywhere - it’s how we translate the key into the index where our item is stored. We use this to get the item, delete it, and of course when we store it for the first time.&lt;/p&gt;

&lt;h3 id=&quot;collisions&quot;&gt;Collisions&lt;/h3&gt;

&lt;p&gt;One thing that comes up with hash tables is the concept of collisions.&lt;/p&gt;

&lt;p&gt;What happens when the hash function generates the same index for two different keys. We want to be able to overwrite keys when they are &lt;em&gt;the same&lt;/em&gt;, but not when we have different keys assigned to the same index.&lt;/p&gt;

&lt;p&gt;There are lots of ways of dealing with this. The way it’s handled in the above mentioned youtube video, and here as well, is by considering each index of the hash table array a &lt;code class=&quot;highlighter-rouge&quot;&gt;bucket&lt;/code&gt; that can store multiple items.&lt;/p&gt;

&lt;p&gt;This complicates the code a bit, and the code’s performance as well when we have multiple items in a bucket.&lt;/p&gt;

&lt;p&gt;Check out the code for the &lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt; method:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//get an index using hash function&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;//check if anything at this index - if there isn't, add item&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;

        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;inserted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;//check everything in this bucket to see if we already have this key&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;

                    &lt;span class=&quot;c1&quot;&gt;//if we come across the same key, replace the old value with the new value&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;

                    &lt;span class=&quot;nx&quot;&gt;inserted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;//if after checking everything in the bucket we haven't added the new value, push it into the bucket now&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;inserted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Without the concept of buckets, this code would be just 3 lines (although there would perhaps be other algorithms needed to check for collisions):&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]];&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In our longer set method, you use the hash function to get the index for this key. You then check if there is anything at this index. If not, we just insert it, no big deal. We need to insert it as &lt;code class=&quot;highlighter-rouge&quot;&gt;[[key, value]]&lt;/code&gt;, because this index is now itself an array. The key-value pair is also an array. So in this implementation, you get a very nested array.&lt;/p&gt;

&lt;p&gt;If there is already something at this index, we have a collision. We need to check if this key already exists here, because we would want to overwrite it. Otherwise, we just push our new key-value pair into the array at this index.&lt;/p&gt;

&lt;p&gt;The remove and get methods need to work similarly, checking if there are multiple items in the bucket, an then iterating through to get the correct one.&lt;/p&gt;

&lt;p&gt;I will reiterate here, that whenever we do this, the time complexity is &lt;strong&gt;no longer O(1) but is now O(n)&lt;/strong&gt;, since it is no longer a simple look-up/get/delete using a single key. The bucket concept makes this less efficient, which I feel defeats the purpose of using this data structure, at least if your concern is time. I’d have to look closer at the other options for handling collisions to see if they are any better.&lt;/p&gt;

&lt;h3 id=&quot;all-the-code&quot;&gt;All the code&lt;/h3&gt;

&lt;p&gt;There may be some issues I haven’t come across yet, but here is the whole HashTable implementation. I like seeing how this can work behind the scenes, but all we really need is objects and maps.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HashTable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;numBuckets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;numBuckets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;_hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;charCodeAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//check length of the bucket - if more than one item, have to iterate through, making the operation O(n)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;undefined&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//check that key matches&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//otherwise, just return the item - O(1) operation&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//get an index using hash function&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//check if anything at this index - if there isn't, add item&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]];&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;inserted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;c1&quot;&gt;//check everything in this bucket to see if we already have this key&lt;/span&gt;

      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;//if we come across the same key, replace the old value with the new value&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

          &lt;span class=&quot;nx&quot;&gt;inserted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;c1&quot;&gt;//if after checking everything in the bucket we haven't added the new value, push it into the bucket now&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;inserted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//if nothing here, return&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//check if this bucket has multiple items, should be able to splice here since we're not depending on the index *inside* the bucket&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;splice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//if one item here, set to undefined&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//originally wanted to use splice, but that changes the index of everything else&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="algorithms" />
      
        <category term="data-structures" />
      
        <category term="coding-problems" />
      
        <category term="javascript" />
      

      
        <summary type="html">Hash tables are a commonly used data structure and, apparently, are commonly asked about in interviews.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Binary trees; isSameTree problem</title>
      <link href="http://localhost:4000/binary-trees" rel="alternate" type="text/html" title="Binary trees; isSameTree problem" />
      <published>2023-07-28T15:30:00-06:00</published>
      <updated>2023-07-28T15:30:00-06:00</updated>
      <id>http://localhost:4000/binary-trees</id>
      <content type="html" xml:base="http://localhost:4000/binary-trees">&lt;p&gt;It’s time to dive into some binary tree coding problems.&lt;/p&gt;

&lt;p&gt;But I think I need to learn more about binary trees, and how to tackle these kinds of problems first, so I actually have a chance of getting them right.&lt;/p&gt;

&lt;p&gt;Resources:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;This was a quick, &lt;a href=&quot;https://www.youtube.com/watch?v=GzJoqJO1zdI&quot;&gt;helpful video&lt;/a&gt; that summarized binary trees nicely&lt;/li&gt;
  &lt;li&gt;This &lt;a href=&quot;https://www.youtube.com/watch?v=5cU1ILGy6dM&quot;&gt;video from freeCodeCamp&lt;/a&gt; describes how to deal with binary search trees in JavaScript&lt;/li&gt;
  &lt;li&gt;This &lt;a href=&quot;https://www.freecodecamp.org/news/binary-search-tree-traversal-inorder-preorder-post-order-for-bst/&quot;&gt;article from freeCodeCamp&lt;/a&gt; summarizing tree traversal&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;compared-to-other-data-structures---linked-lists&quot;&gt;Compared to other data structures - linked lists&lt;/h3&gt;

&lt;p&gt;Like linked lists, trees are made up of nodes that have data and pointers.&lt;/p&gt;

&lt;p&gt;I’ve delved a bit into singly linked-lists, whose nodes have one pointer. In comparison, trees can have multiple pointers to the next nodes. In the case of a binary tree, a node points towards a maximum of 2 child nodes. Each node can have a &lt;code class=&quot;highlighter-rouge&quot;&gt;left&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;right&lt;/code&gt; pointer, comparable to the &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt; pointer in a linked list.&lt;/p&gt;

&lt;p&gt;The top node of the tree is called the &lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt; node, comparable to the &lt;code class=&quot;highlighter-rouge&quot;&gt;head&lt;/code&gt; node of a linked list. Nodes with no children are called &lt;code class=&quot;highlighter-rouge&quot;&gt;leaf&lt;/code&gt; nodes. The path from the root to a leaf is called a &lt;code class=&quot;highlighter-rouge&quot;&gt;branch&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;traversing-a-binary-tree&quot;&gt;Traversing a binary tree&lt;/h3&gt;

&lt;p&gt;For starters, there are two main approaches to code a tree traversal:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;using a &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; loop and an “on” pointer (like for linked lists, using a “current” pointer with a while loop)&lt;/li&gt;
  &lt;li&gt;recursion&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When you use recursion it’s called branching recursion. Since a node can have multiple children, your stack frame can be branching too.&lt;/p&gt;

&lt;p&gt;Often you need to visit every node in the tree, but how do I know what order to visit in? There are three main types of traversal:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;in-order traversal&lt;/strong&gt;: visit left subtree, then root, then right subtree. Like you’ve moving across the tree from left to right. If you printed out each node as you visted them, they would be in ascending order from left-most to right-most node.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;pre-order traversal&lt;/strong&gt;: visit root, then left subtree, then right subtree. Like you’ve moving from top of tree to bottom (root to leaf). Use if you need to explore the tree from root to leaf, good for making copies of trees.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;post-order traversal&lt;/strong&gt;: visit left subtree, right subtree, then root. Like you’re travelling from the bottom up (leaf to root). Use if you need to explore leaves before roots. Good for deleting a tree.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;coding-problem-issametree-solved-with-recursion&quot;&gt;Coding problem: isSameTree, solved with recursion&lt;/h3&gt;

&lt;p&gt;The first coding problem I worked on to practice binary trees was, given two trees &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;q&lt;/code&gt;, determine if they are the same. If they are the same, they have the same structure AND values at each node.&lt;/p&gt;

&lt;p&gt;I decided to try solving this recursively. Sometimes I still struggle with recursion, due to its nested nature. One thing that helps me is to remember that I should always be returning whatever data type the final result is looking for. In this case, we are looking for a boolean, so my base cases must all return true or false. It’s also helpful to think of recursion as repeating sub-problems. What is the sub-problem you are trying to solve here, over and over again?&lt;/p&gt;

&lt;p&gt;In this case, the sub-problem is checking if the current nodes p and q are equal.&lt;/p&gt;

&lt;p&gt;After checking base cases, you need some logic for checking your next values. That’s where your recursive calls come in. Then, you need to do something with the result of those calls. The outer function could return at this point, or maybe you need to add the result to another data structure you’re keeping track of, like a memo object.&lt;/p&gt;

&lt;p&gt;This is what I came up with, and it submitted to leetcode successfully:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isSameTree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//base cases&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;//continue exploring tree&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;isSameTree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;isSameTree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;First, the base cases:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;both p and q are null: in this case return true, because they are equal, and we have reached a leaf node. This branch has nothing else to explore and if we got this far, it is the same for p and q&lt;/li&gt;
  &lt;li&gt;one of p &lt;strong&gt;or&lt;/strong&gt; q, &lt;strong&gt;not both&lt;/strong&gt;, is null: if one node is null and the other is not, they are not &lt;em&gt;structurally&lt;/em&gt; equal, so return false&lt;/li&gt;
  &lt;li&gt;check if the &lt;strong&gt;values&lt;/strong&gt; of p and q are equal. If not, return false. Otherwise, the nodes so far are equal and there is more tree to explore, so we can move on.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Next step: recursive calls&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;we need explore the left and right subtrees for our p and q nodes. If either of these returns false, it means p and q were not equal.&lt;/li&gt;
  &lt;li&gt;this is where you start to see branching recursion come into play, since you have to check the left and right child of every node.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Finally, if we got through all of that and never encountered unequal structure or values, we can return true.&lt;/p&gt;

&lt;h3 id=&quot;next-steps&quot;&gt;Next steps&lt;/h3&gt;

&lt;p&gt;I definitely need more practice with binary trees, so I’ll continue learning and practicing and will update here if I find anything notable.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="algorithms" />
      
        <category term="data-structures" />
      
        <category term="coding-problems" />
      
        <category term="recursion" />
      

      
        <summary type="html">It’s time to dive into some binary tree coding problems.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">More data structures - JavaScript</title>
      <link href="http://localhost:4000/data-structures-javascript" rel="alternate" type="text/html" title="More data structures - JavaScript" />
      <published>2022-03-11T15:30:00-07:00</published>
      <updated>2022-03-11T15:30:00-07:00</updated>
      <id>http://localhost:4000/data-structures-javascript</id>
      <content type="html" xml:base="http://localhost:4000/data-structures-javascript">&lt;p&gt;Last year I began learning more about data structures. I found myself often wondering how the theory I was learning would apply to JavaScript, the language I code in most frequently.&lt;/p&gt;

&lt;p&gt;Currently I am going through a &lt;a href=&quot;https://www.youtube.com/watch?v=t2CEgPsws3U&amp;amp;list=WL&amp;amp;index=21&amp;amp;t=3s&quot;&gt;tutorial on JavaScript data structures&lt;/a&gt;, and I will make some notes here as I learn.&lt;/p&gt;

&lt;p&gt;You are able to use built-in data structures in JavaScript for some of these, and others you need to code yourself.&lt;/p&gt;

&lt;p&gt;The instructor uses object-oriented programming, creating classes for the types of data structures, and methods within those classes that can be used to interact with the data structure.&lt;/p&gt;

&lt;p&gt;Some helpful articles:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.educative.io/blog/javascript-data-structures&quot;&gt;https://www.educative.io/blog/javascript-data-structures&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.freecodecamp.org/news/10-common-data-structures-explained-with-videos-exercises-aaff6c06fb2b&quot;&gt;https://www.freecodecamp.org/news/10-common-data-structures-explained-with-videos-exercises-aaff6c06fb2b&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;stack&quot;&gt;Stack&lt;/h3&gt;

&lt;p&gt;Stacks operate with a Last In First Out (LIFO) functionality - the last thing you put onto your stack is the first thing that will be removed, like if you had a stack of books or plates.&lt;/p&gt;

&lt;p&gt;Examples of JavaScript functions that work like this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;the .push() method, which adds to the top of a stack&lt;/li&gt;
  &lt;li&gt;the .pop() method, which removes from the top of a stack&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JavaScript already has the build in methods that enable you to use an array as a stack.&lt;/p&gt;

&lt;h3 id=&quot;set&quot;&gt;Set&lt;/h3&gt;

&lt;p&gt;Like an array, but all items are unique - no duplicates.&lt;/p&gt;

&lt;p&gt;You can &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;read more about sets on MDN&lt;/a&gt;. There is a built in Set function in ES6.&lt;/p&gt;

&lt;p&gt;Using this functionality, you create a new set using the Set() constructor, like this:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;mySet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There are several built-in methods you can use to interact with your set.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;add() - adds a value to the set&lt;/li&gt;
  &lt;li&gt;has() - checks if the set has a particular item&lt;/li&gt;
  &lt;li&gt;delete() - deletes a value from the set&lt;/li&gt;
  &lt;li&gt;clear() - clears the whole set&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are some methods that you might want to use with sets generally, but aren’t included in ES6. You’d need to create your own set class with these methods:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;union: combines multiple sets and leaves out duplicate items&lt;/li&gt;
  &lt;li&gt;intersection: compares two sets, returns a new set that includes items that are in &lt;strong&gt;both&lt;/strong&gt; sets&lt;/li&gt;
  &lt;li&gt;difference: compares two sets, returns items that are in one set but not the other set&lt;/li&gt;
  &lt;li&gt;subset: tests if one set is a subset of another set - so if one set is fully contained within another set&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;queue&quot;&gt;Queue&lt;/h3&gt;

&lt;p&gt;Follows a First In First Out (FIFO) pattern - the first item placed into the queue is the first item that is processed.&lt;/p&gt;

&lt;p&gt;In JavaScript you can use an array for this, or create your own class with more methods.&lt;/p&gt;

&lt;p&gt;Some built in JavaScript methods:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;.push() - add to the end of an array&lt;/li&gt;
  &lt;li&gt;.shift() - remove from the beginning of an array&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Some methods that queues sometimes use, that are not built into JavaScript:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;front() - tells you what’s at the beginning of your queue - in JavaScript we would just do &lt;code class=&quot;highlighter-rouge&quot;&gt;myArray[0] &lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;size() - just use &lt;code class=&quot;highlighter-rouge&quot;&gt;myArray.length&lt;/code&gt; to get size&lt;/li&gt;
  &lt;li&gt;isEmpty() - just check the length of the array &lt;code class=&quot;highlighter-rouge&quot;&gt;myArray.length === 0 &lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can also create &lt;strong&gt;priority queues.&lt;/strong&gt; Again, this is a functionality you would need to create. You pass in the item as well as it’s priority, and it is added to the queue based on priority.&lt;/p&gt;

&lt;p&gt;One way of checking priorities is to use a for loop. Each item you put into the queue is its own array, at the 0 index is the item and at 1 index is a number for its priority. For each element already in the queue, compare its priority value to the incoming item’s priority value. If the incoming priority value is less than the item we are comparing to, we add it to the queue at this position using the “splice” method.&lt;/p&gt;

&lt;h3 id=&quot;tree&quot;&gt;Tree&lt;/h3&gt;

&lt;p&gt;A tree is a branching data structure, where all data points are called nodes. The top node is called the “root” node. Nodes with their own branches are called parent nodes, and nodes branching from them are called child nodes.&lt;/p&gt;

&lt;p&gt;In a &lt;strong&gt;binary tree,&lt;/strong&gt; each node can only have two branches. Nodes in a left subtree must have a value of less than or equal to the parent node. Nodes in a right subtree must have a value of greater than or equal its parent node.&lt;/p&gt;

&lt;p&gt;Using binary search, you don’t have to check every single item for what you’re looking for, and you are able to skip about half the tree. Time taken for the search is proportional to the logarithm of the number of items in the tree, with a big O notion of O(log n). So it’s pretty fast, but slower than searching a hash table.&lt;/p&gt;

&lt;p&gt;Some tree traversal methods (ways of exploring the data in the tree):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;in order: begin search at left-most node and end at right-most node; gives values in order from smallest to largest&lt;/li&gt;
  &lt;li&gt;pre order: start at root nodes before looking at leaves&lt;/li&gt;
  &lt;li&gt;post order: start at leaf nodes before going to roots&lt;/li&gt;
  &lt;li&gt;level order: explores all nodes on a level of the tree before moving on to the next level, starting at the root node&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hash-table&quot;&gt;Hash table&lt;/h3&gt;

&lt;p&gt;Hash tables are used for key-value pairs, like maps or objects. They are very efficient and searching doesn’t depend on the number of items, with a big O notion of O(1).&lt;/p&gt;

&lt;p&gt;They work by putting your key into a hash function, which assigns strings to a number, usually an index in an array. The value is stored here.&lt;/p&gt;

&lt;h3 id=&quot;linked-list&quot;&gt;Linked list&lt;/h3&gt;

&lt;p&gt;A list where items are stored in nodes. Nodes contain the item and a reference to the next node.&lt;/p&gt;

&lt;p&gt;When performing any operation on a linked list you always have to start at the beginning of the list, or head node. You can’t just access something in the middle of the list without going through the items preceding it.&lt;/p&gt;

&lt;h3 id=&quot;binary-heap&quot;&gt;Binary heap&lt;/h3&gt;

&lt;p&gt;It has a similar structure to a binary tree, but the ordering is different and is one of two types:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;max heap: parent nodes are greater than or equal to child nodes&lt;/li&gt;
  &lt;li&gt;min heap: parent nodes are less than or equal to child nodes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The order the values within a level does not matter. Levels are filled from left to right.&lt;/p&gt;

&lt;p&gt;Arrays are used to implement heaps in JavaScript. You add values to the array starting at &lt;strong&gt;index 1, not 0. Index 0 is assigned null.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You can calculate where elements are in the array using the calculations below, where i is your current index (or position in the tree):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Left child is i * 2&lt;/li&gt;
  &lt;li&gt;Right child is i * 2 + 1&lt;/li&gt;
  &lt;li&gt;Parent is i / 2&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;graphs&quot;&gt;Graphs&lt;/h3&gt;

&lt;p&gt;Graphs contain nodes, or vertices, connected by edges. You can have directed or undirected graphs - meaning, the edges of the graph can have direction, or no direction, respectively.&lt;/p&gt;

&lt;p&gt;An example of an undirected graph could be a social network, where nodes are people and edges are whether or not they are connected/know each other.&lt;/p&gt;

&lt;p&gt;How to traverse a graph:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;breadth-first search: start at one node, visit all its neighbours that are one edge away first, then visits all their neighbours. Keep in mind the graph is directed or undirected - a node could look like it’s one edge away, but if you can’t move in that direction, you can’t go to that node in one move.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;I was hoping to find more concrete examples of real applications of data structures in JavaScript. What I did get out of this, though, is a review of basic data structures, and an understanding of how I could create any of these data structures using classes in JavaScript.&lt;/p&gt;

&lt;p&gt;There is a lot more learning I can do with data structures and algorithms. One big take-away is that choosing the right data structure is all about the problem you are trying to solve, and how to solve it efficiently. My strategy going forward may be to deal with it on a case by case basis - when trying to solve a problem I can use my basic knowledge of data structures to think about the most efficient solution, and do more research from there if needed. Built-in JavaScript methods and data structures, like arrays, maps, and objects, have been enough to solve my problems so far, so maybe I don’t need to get too advanced yet.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="javascript" />
      
        <category term="data-structures" />
      

      
        <summary type="html">Last year I began learning more about data structures. I found myself often wondering how the theory I was learning would apply to JavaScript, the language I code in most frequently.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Learning data structures - advanced structures (trees)</title>
      <link href="http://localhost:4000/data-structures-3" rel="alternate" type="text/html" title="Learning data structures - advanced structures (trees)" />
      <published>2021-07-07T14:30:00-06:00</published>
      <updated>2021-07-07T14:30:00-06:00</updated>
      <id>http://localhost:4000/data-structures-3</id>
      <content type="html" xml:base="http://localhost:4000/data-structures-3">&lt;p&gt;This is the last section of intro to data structures. We are now getting into non-linear data structures.&lt;/p&gt;

&lt;p&gt;Everything up to this point has been a linear structure. The next data structures to cover are trees.&lt;/p&gt;

&lt;p&gt;Once again following along with &lt;a href=&quot;https://www.youtube.com/watch?v=zg9ih6SVACc&amp;amp;t=7744s&quot;&gt;this video&lt;/a&gt; and supplementing with other sources.&lt;/p&gt;

&lt;h3 id=&quot;trees&quot;&gt;Trees&lt;/h3&gt;

&lt;p&gt;Nodes in a tree have a hierarchical relationship. Nodes can point to multiple nodes instead of just one, like we saw in linked lists.&lt;/p&gt;

&lt;p&gt;There are lots of different types of trees, but one important one is called a &lt;strong&gt;binarysearch tree&lt;/strong&gt; .&lt;/p&gt;

&lt;p&gt;Binary search tree:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;some rules:
    &lt;ul&gt;
      &lt;li&gt;nodes can only have 2 children&lt;/li&gt;
      &lt;li&gt;the child to the left of the parent must be less than or equal to the parent while the child to the right must be greater than or equal to the parent&lt;/li&gt;
      &lt;li&gt;nodes cannot have the same value&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;can perform searches on the tree in a logarithmic time&lt;/li&gt;
  &lt;li&gt;at any given node during a search, choose left or right depending on if the value is less than or greater than the value at the current node&lt;/li&gt;
  &lt;li&gt;these are good for storing large amounts of data because they are quick to search - for BigO notation, I believe that makes it O(log n)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Another tree that is used is called a &lt;strong&gt;Trie&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;these store letters of the alphabet&lt;/li&gt;
  &lt;li&gt;to retrieve word based data&lt;/li&gt;
  &lt;li&gt;each node has an array that includes references to letters&lt;/li&gt;
  &lt;li&gt;the nodes basically spell out words as you go down the different paths on the tree&lt;/li&gt;
  &lt;li&gt;the end of a word is marked by a flag - so nodes contain pointers to letters that follow as well as flags for the ends of words&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Heaps:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;parent nodes compare to child nodes and whether they are greater than or less than&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;min-heap:&lt;/strong&gt; root node is the minimum compared to the children&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;max-heap:&lt;/strong&gt; root node is the maximum compared to the children&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Graphs:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;made up of nodes and edges (paths between the nodes)&lt;/li&gt;
  &lt;li&gt;not linear&lt;/li&gt;
  &lt;li&gt;undirected graphs: direction between nodes doesn’t matter&lt;/li&gt;
  &lt;li&gt;directed graph: direction does matter&lt;/li&gt;
  &lt;li&gt;cyclic graph: nodes have a path back to itself (undirected count, since you can go any direction back to the start)&lt;/li&gt;
  &lt;li&gt;acyclic graph: no path from one node back to itself&lt;/li&gt;
  &lt;li&gt;edges can have a weight - kind of like distance between nodes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When to use trees?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;any time you have hierarchical data&lt;/li&gt;
  &lt;li&gt;tries are used by things like spellcheck and autocomplete features&lt;/li&gt;
  &lt;li&gt;heaps used for sorting algorithms like HeapSort, and priority queues&lt;/li&gt;
  &lt;li&gt;graphs: used in shortest path algorithm, social media users, and more&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;That’s it for intro data structures! These posts probably read way more like notes than actual blog posts, but as I am still learning data structures I don’t have much else to share.&lt;/p&gt;

&lt;p&gt;It’s interesting to learn the theory but I kept wondering how I would actually apply this in real projects. Especially in Javascript projects. Do all these data structures exist in Javascript? Do they go by different names? I still have a lot of questions.&lt;/p&gt;

&lt;p&gt;My next step will be to learn about Javascript specific data structures and real life applications.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="computer-science" />
      
        <category term="data-structures" />
      

      
        <summary type="html">This is the last section of intro to data structures. We are now getting into non-linear data structures.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Learning data structures - intermediate structures</title>
      <link href="http://localhost:4000/data-structures-2" rel="alternate" type="text/html" title="Learning data structures - intermediate structures" />
      <published>2021-06-10T14:30:00-06:00</published>
      <updated>2021-06-10T14:30:00-06:00</updated>
      <id>http://localhost:4000/data-structures-2</id>
      <content type="html" xml:base="http://localhost:4000/data-structures-2">&lt;p&gt;Now we are getting into some intermediate topics in data structures.&lt;/p&gt;

&lt;p&gt;Again I am following along with the &lt;a href=&quot;https://www.youtube.com/watch?v=zg9ih6SVACc&amp;amp;t=3551s&quot;&gt;freeCodeCamp video&lt;/a&gt; on data structures as I learn.&lt;/p&gt;

&lt;p&gt;We are now going to be going over sequential access data structures. Unlike random access data structures, you can access items only in a certain order, which means you are depending on other items in the data structure. You can’t get items instantly like you can with arrays.&lt;/p&gt;

&lt;h3 id=&quot;stacks&quot;&gt;Stacks&lt;/h3&gt;

&lt;p&gt;Stacks follow the “last in first out” principle - the last item you add is the first item to be removed.&lt;/p&gt;

&lt;p&gt;The video has a great analogy for this where they envision a stack of books. If you wanted to grab a book from the middle of the stack, you first have to remove all the other books on top, in order, otherwise the whole thing will collapse.&lt;/p&gt;

&lt;p&gt;I also thought of this like a stack of plates. The last one you put on top of the stack is the first one you will use.&lt;/p&gt;

&lt;p&gt;Some stack methods:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;push: adds to top of stack&lt;/li&gt;
  &lt;li&gt;pop: removes from top of stack&lt;/li&gt;
  &lt;li&gt;peek: get the value of the top item, without removing it&lt;/li&gt;
  &lt;li&gt;contains: to find something within the stack&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Interestingly, pop and push are the same names as common Javascript array methods. The contains method reminds me of the Javascript array method “includes”. This is definitely making me think I need to find a Javascript specific data structures resource.&lt;/p&gt;

&lt;p&gt;BigO efficiency:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;accessing, searching: O(n)&lt;/li&gt;
  &lt;li&gt;inserting, deleting: O(1), because you just do push or pop once&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When would you use stacks?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;for recursion - when functions call themselves repeatedly&lt;/li&gt;
  &lt;li&gt;a back button in the browser - add your pages/actions to a stack&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;queues&quot;&gt;Queues&lt;/h3&gt;

&lt;p&gt;Follows a first in first out principle. Just like a line-up in real life. The first person in the line is the first person served.&lt;/p&gt;

&lt;p&gt;Some queue methods:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;enqueue: add to the end/tail of the queue&lt;/li&gt;
  &lt;li&gt;dequeue: remove from the start/head of the queue&lt;/li&gt;
  &lt;li&gt;peek: tells us the value at the head of the queue&lt;/li&gt;
  &lt;li&gt;contains: if our queue contains are specific element&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BigO efficiency:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;accessing, searching: O(n)&lt;/li&gt;
  &lt;li&gt;inserting, deleting: O(1), because you just do enqueue or dequeue once, same as the stack&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I actually use queues fairly often when working with AWS, particularly SQS queues. Events can be added to a queue, and processed by, for example, a Lambda function in the order they are received, when the function is ready for the next one.&lt;/p&gt;

&lt;h3 id=&quot;linked-lists&quot;&gt;Linked lists&lt;/h3&gt;

&lt;p&gt;I was very interested in learning what exactly a linked list is. I hear about them all the time but don’t actually know what they do.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sequential&lt;/li&gt;
  &lt;li&gt;each element is called a node, and a node contains data and a reference to the next node&lt;/li&gt;
  &lt;li&gt;nodes are objects and can have multiple values&lt;/li&gt;
  &lt;li&gt;the reference is what &lt;em&gt;links&lt;/em&gt; the elements together into a list&lt;/li&gt;
  &lt;li&gt;the last node reference points towards a null value&lt;/li&gt;
  &lt;li&gt;can add or remove items anywhere in the list, unlike stacks and queues, but this means you also have to change the references&lt;/li&gt;
  &lt;li&gt;can only go forwards, not backwards&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Linked list methods:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;add to head of list: need to add a reference to the former head node,&lt;/li&gt;
  &lt;li&gt;remove from head: just set reference to null&lt;/li&gt;
  &lt;li&gt;add to middle: reference of new node needs to be to the next item in the list, and the item before must have its reference updated to that of the new node&lt;/li&gt;
  &lt;li&gt;remove from middle: set the reference of the node before to point to the node after the one you’re removing, then update the reference of the one you’re removing to null&lt;/li&gt;
  &lt;li&gt;add to the end: make the tail node point to the new node&lt;/li&gt;
  &lt;li&gt;remove from the end: set the node before the tail node to null&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BigO efficiency:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;accessing, searching: O(n) - still need to go through each node before we get to the one we want, using the pointers to get us there&lt;/li&gt;
  &lt;li&gt;inserting, deleting: can be O(n) or O(1), depending on if you’re adding to the beginning/end or in the middle&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So how are these actually used? In situations where one thing points to another&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;music playlists&lt;/li&gt;
  &lt;li&gt;photo albums&lt;/li&gt;
  &lt;li&gt;can work with queues and stacks behind the scenes&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;doubly-linked-lists&quot;&gt;Doubly linked lists&lt;/h3&gt;

&lt;p&gt;Regular linked lists could only point forwards, but doubly linked lists can point forwards and backwards.&lt;/p&gt;

&lt;p&gt;You don’t just have a pointer to the next node, you also have a pointer to the previous node.&lt;/p&gt;

&lt;p&gt;Like a linked list, there is a head and tail node. The first pointer of the head node points to a null value, as well as the second pointer of the tail node.&lt;/p&gt;

&lt;p&gt;BigO efficiency: the same as for linked lists&lt;/p&gt;

&lt;p&gt;Uses - basically whenever you want to go back and forth between things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;browser caches&lt;/li&gt;
  &lt;li&gt;undo/redo&lt;/li&gt;
  &lt;li&gt;open recent functionality&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dictionaries&quot;&gt;Dictionaries&lt;/h3&gt;

&lt;p&gt;These are also called associated arrays and maps. So in Javascript, a dictionary is referred to as a map (not the same as the map function).&lt;/p&gt;

&lt;p&gt;Dictionaries store data in key-value pairs. Keys can be any primitive data type. Keys must be unique and can only have one value assigned to them. This makes it easier and faster to look up values later. Values do not have to be unique, however.&lt;/p&gt;

&lt;h4 id=&quot;hash-tables&quot;&gt;Hash tables&lt;/h4&gt;

&lt;p&gt;During the lesson on dictionaries the instructor went over hash tables. Yet another term I’ve heard a lot about and never understood.&lt;/p&gt;

&lt;p&gt;Hash tables help you to store keys from a dictionary while cutting down on nil/empty values being taken up in memory. A hash function is what assigns keys to locations in memory so they can be retrieved easily later.&lt;/p&gt;

&lt;p&gt;Dictionaries are built on hash tables.&lt;/p&gt;

&lt;p&gt;Ok, back to dictionaries.&lt;/p&gt;

&lt;p&gt;BigO efficiency: in the case of dictionaries, we can’t just use the worst case scenario, things get pretty complicated due to hash tables.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;for the average efficiency, all operations are O(1). That is because they are key-value pairs, so it’s quick to look up a value based on its key. You don’t have to spend a lot of time searching through your data structure to perform your operation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dictionaries are overall very useful data structures that can be used in many situations.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;That’s it for the intermediate data structures. The deeper I go into all of this, the more I want to find information on how these all apply to Javascript specifically. I’ll finish up the rest of the data structures in this course, and find more information on data structures in Javascript.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="computer-science" />
      
        <category term="data-structures" />
      

      
        <summary type="html">Now we are getting into some intermediate topics in data structures.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Learning data structures - performance and basic structures</title>
      <link href="http://localhost:4000/data-structures" rel="alternate" type="text/html" title="Learning data structures - performance and basic structures" />
      <published>2021-05-23T14:30:00-06:00</published>
      <updated>2021-05-23T14:30:00-06:00</updated>
      <id>http://localhost:4000/data-structures</id>
      <content type="html" xml:base="http://localhost:4000/data-structures">&lt;p&gt;It felt like it was about time to dive deeper into data structures.&lt;/p&gt;

&lt;p&gt;This is one of those topics that I knew I needed to learn in more depth eventually, but didn’t get around to until now. I was working on a difficult programming problem where I had to convert some data from one structure to another for my front end to be able to use it. I was frustrated because I felt like I had a gap in my knowledge - how do I create and work with these data structures efficiently? Through a lot of trial and error I figured it out, but it likely would have been easier if I had more knowledge of the specific structures I was using - in this case, objects and maps in Javascript.&lt;/p&gt;

&lt;h3 id=&quot;what-is-a-data-structure&quot;&gt;What is a data structure?&lt;/h3&gt;

&lt;p&gt;Turns out my idea of data structures as a concept wasn’t too far off - the &lt;a href=&quot;https://www.youtube.com/watch?v=zg9ih6SVACc&amp;amp;list=WL&amp;amp;index=7&quot;&gt;free code camp video I’m using to help me learn&lt;/a&gt; defined a data structure as something that stores data and allows a user to manipulate that data.&lt;/p&gt;

&lt;p&gt;Things you might want to do with a data structure include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;accessing the data&lt;/li&gt;
  &lt;li&gt;searching the data&lt;/li&gt;
  &lt;li&gt;inserting a new item&lt;/li&gt;
  &lt;li&gt;deleting an item&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;big-o-notation&quot;&gt;Big-O Notation&lt;/h3&gt;

&lt;p&gt;This helps us to determine how efficient our data structures are. It measures the complexity of an algorithm.&lt;/p&gt;

&lt;p&gt;I found &lt;a href=&quot;https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation&quot;&gt;this article that helps explain this concept for beginners&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You essentially score a data structure based on how it performs if you increase the size of the data input into your program.&lt;/p&gt;

&lt;p&gt;You give a score to the data structure for how well it can accomplish the tasks mentioned above (access, search, insert, delete). When you are choosing how to store your data, you should choose the data structure that is most efficient at the thing you are mainly using it for.&lt;/p&gt;

&lt;p&gt;Performance of a function is based on the &lt;strong&gt;number of operations&lt;/strong&gt; it takes to complete its task.&lt;/p&gt;

&lt;p&gt;We measure performance by using equations that take in the size of the data set. This equation returns the number of operations. These are called Time Complexity Equations. We don’t actually measure time, however, as that can vary depending on the machine you are using to run your program.&lt;/p&gt;

&lt;h4 id=&quot;most-common-time-complexity-equations-from-highest-to-lowest-efficiency&quot;&gt;Most common Time Complexity Equations, from highest to lowest efficiency&lt;/h4&gt;

&lt;p&gt;n = the size of the data set&lt;/p&gt;

&lt;p&gt;The first three are pretty good:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O(1)&lt;/strong&gt;: the best possible score is 1. This means that the task can be completed with one operation. It always takes the same amount of time regardless of the size of the data set it is working with.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O(log n)&lt;/strong&gt;: still very fast; the larger the data set, the more efficient it is. Follows a logarithmic curve (the inverse of an exponential curve, if like me you don’t remember much about logarithmic curves from school).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;example algorithm that uses this: binary search&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;O(n)&lt;/strong&gt;: the number of operations needed is proportional to the number of items in the data set. This would be represented by a linear graph.&lt;/p&gt;

&lt;p&gt;The next three are not so good:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O(n log n)&lt;/strong&gt;: not quite linear, performance gets slightly worse as the size of the data set increases&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O(n^2) and O(2^n)&lt;/strong&gt;: gets exponentially worse as the size increases&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;n^2 can happen with nested loops&lt;/li&gt;
  &lt;li&gt;you could end up with n^3, n^4 and larger if you have even more code nested with in your nests&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;basic-data-structures---arrays-and-array-lists&quot;&gt;Basic data structures - arrays and array lists&lt;/h3&gt;

&lt;p&gt;Arrays and array lists are random-access data structures. This means you can access any element inside them directly without depending on any of the other elements.&lt;/p&gt;

&lt;h4 id=&quot;arrays&quot;&gt;Arrays&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;can be used to store anything, usually similar values&lt;/li&gt;
  &lt;li&gt;items in an array are called elements&lt;/li&gt;
  &lt;li&gt;indexes are used to identify the elements in the array, starting at index 0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Parallel arrays: multiple arrays have corresponding values, like employees and their salaries&lt;/p&gt;

&lt;p&gt;There was a point when I started to become confused while watching the freeCodeCamp video. They say that an array can store data of only one type. This isn’t true in Javascript, as it is an un-typed language. You can also add and remove items in a Javascript array, so the size is not always fixed; in the video, fixed-size was an important aspect of the array data structure. If my understanding of data storage is correct, this means that you cannot reserve continuous spaces in memory for all your array elements (in Javascript). This could affect how the data is accessed and therefore its performance.&lt;/p&gt;

&lt;p&gt;Moving on…&lt;/p&gt;

&lt;p&gt;You can have two-dimensional arrays:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;at each index of the first array, there is another array&lt;/li&gt;
  &lt;li&gt;looks like a spreadsheet&lt;/li&gt;
  &lt;li&gt;use two indexes to access each item, first for column and second for row&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BigO efficiency for arrays:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;accessing: O(1)&lt;/li&gt;
  &lt;li&gt;searching, deleting, inserting: O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;array-lists&quot;&gt;Array lists&lt;/h4&gt;

&lt;p&gt;This began to clear up my confusion about Javascript arrays and size. An array list has the same properties as an array, except it is dynamic and can grow. Exactly what I’m used to with Javascript. So, in Javascript, is an “array” actually an “array list”? That is something I need to dive into further.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;array lists usually use arrays in the background. Some languages, like Python (and possibly Javascript?) mix properties of arrays and array lists.&lt;/li&gt;
  &lt;li&gt;has built-in methods. Javascript has methods like pop, unshift, and length, to name a few.&lt;/li&gt;
  &lt;li&gt;in memory, array list items are stored as references to other places in memory - the actual element values are stored elsewhere in memory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BigO efficiency for array lists:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;accessing: O(1)&lt;/li&gt;
  &lt;li&gt;searching, inserting, deleting: O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For both arrays and array lists, searching, inserting, and deleting will require us to go through each item to complete the task (you could also find the correct element on the first try, but for BigO notation we look at the worst case scenario).&lt;/p&gt;

&lt;p&gt;Use arrays if:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;you won’t be changing the size or modifying the data&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Otherwise, array lists are more powerful and a better choice. As we can see above, the efficiency in terms of BigO are the same.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;That’s all for the basics. The next posts will get into the intermediate and advanced data structures.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="computer-science" />
      
        <category term="data-structures" />
      

      
        <summary type="html">It felt like it was about time to dive deeper into data structures.</summary>
      

      
      
    </entry>
  
</feed>
