<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="https://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="http://localhost:4000/tag/computer-science/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2024-10-19T22:53:02-06:00</updated>
  <id>http://localhost:4000/tag/computer-science/feed.xml</id>

  
  
  

  
    <title type="html">Julia Hack | </title>
  

  
    <subtitle>Web development blog</subtitle>
  

  

  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">Big O For JavaScript Objects and Arrays</title>
      <link href="http://localhost:4000/object-array-efficiency" rel="alternate" type="text/html" title="Big O For JavaScript Objects and Arrays" />
      <published>2024-10-19T18:30:00-06:00</published>
      <updated>2024-10-19T18:30:00-06:00</updated>
      <id>http://localhost:4000/object-array-efficiency</id>
      <content type="html" xml:base="http://localhost:4000/object-array-efficiency">&lt;p&gt;Quick post to summarize different operations on objects and arrays.&lt;/p&gt;

&lt;p&gt;This content came from a lesson in JavaScript Algorithms and Data Structures Masterclass on Udemy.&lt;/p&gt;

&lt;h3 id=&quot;objects&quot;&gt;Objects&lt;/h3&gt;

&lt;p&gt;Objects are unordered collections of key-value pairs. If you have the key, you can retrive the value immediately without searching the entire object. This is constant time, O(1).&lt;/p&gt;

&lt;p&gt;It’s the same thing for inserting new items. Order doesn’t come into play, you’re just adding a new item into the object, so it’s constant time.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.keys()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Object.entries()&lt;/code&gt;: since this converts an object to an array, so you can iterate over it, it is O(n) time. That’s because you have to go through every item in the object in order to create the new array.&lt;/p&gt;

&lt;p&gt;Objects are great for when order doesn’t matter and you just need to look things up.&lt;/p&gt;

&lt;h3 id=&quot;arrays&quot;&gt;Arrays&lt;/h3&gt;

&lt;p&gt;Arrays are more useful for when you need order and/or fast access. If you know the index of the item you’re looking for, you don’t have to search the whole array - you can retrieve it right away, making it constant time O(1).&lt;/p&gt;

&lt;p&gt;Searching the entire array is O(n), because we are considering the worst case scenario - that the item you’re looking for it at the very end, and you have to go through all the other items first.&lt;/p&gt;

&lt;p&gt;Insert or removing an item depends on &lt;em&gt;where&lt;/em&gt; in the array you are adding/removing from.&lt;/p&gt;

&lt;p&gt;If you are adding to the end (&lt;code class=&quot;highlighter-rouge&quot;&gt;push()&lt;/code&gt;) or removing from the end (&lt;code class=&quot;highlighter-rouge&quot;&gt;pop()&lt;/code&gt;), you don’t have to touch any other items in the array. These are constant time O(1).&lt;/p&gt;

&lt;p&gt;However, if you are adding (&lt;code class=&quot;highlighter-rouge&quot;&gt;unshift()&lt;/code&gt;) or removing (&lt;code class=&quot;highlighter-rouge&quot;&gt;shift()&lt;/code&gt;) from the beginning of the array, you now have to re-index every other item in that array.&lt;/p&gt;

&lt;p&gt;Let’s say you added one item to the beginning. It is now index 0. The next item in the array, that was previously index 0, now has to be re-indexed to 1. And so on. Since you are updating every item in the new array, time complexity is O(n).&lt;/p&gt;

&lt;p&gt;In general, any built in JavaScript method that acts on (potentially) every item of an array is O(n), including:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;splice()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;slice()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;concat()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;map()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;forEach()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sort()&lt;/code&gt; is O(n log(n)) - because there are comparisons and other complex operations going on for each element in the array:&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="computer-science" />
      
        <category term="data-structures" />
      
        <category term="javascript" />
      

      
        <summary type="html">Quick post to summarize different operations on objects and arrays.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Revisiting Data Structures and Algorithms - Big O Notation</title>
      <link href="http://localhost:4000/big-o" rel="alternate" type="text/html" title="Revisiting Data Structures and Algorithms - Big O Notation" />
      <published>2024-10-19T17:30:00-06:00</published>
      <updated>2024-10-19T17:30:00-06:00</updated>
      <id>http://localhost:4000/big-o</id>
      <content type="html" xml:base="http://localhost:4000/big-o">&lt;p&gt;I am learning about data structures and algorithms again.&lt;/p&gt;

&lt;p&gt;A while ago I wanted to try Leetcode to get better at solving code problems. It was good practice, but I found that if I picked random problems to work on, I could usually come with a solution, but the problems sometimes are testing your knowledge of specific algorithms. How am I supposed to get the “correct” answer if I have never studied the algorithm? I don’t want to just google the answer to every question, this defeats the whole purpose.&lt;/p&gt;

&lt;p&gt;I figured I should try learning more algorithms, and once I learn them, &lt;em&gt;then&lt;/em&gt; I should practice them.&lt;/p&gt;

&lt;p&gt;This time around for data structures and algorithms, I found a course that teaches this topic for JavaScript. The first lesson is on Big O Notation.&lt;/p&gt;

&lt;p&gt;This course is the JavaScript Algorithms and Data Structures Masterclass on Udemy.&lt;/p&gt;

&lt;p&gt;I generally understand the concepts behind Big O, but I sometimes struggle to analyze the time and space complexity for different solutions to a problem.&lt;/p&gt;

&lt;h3 id=&quot;counting-operations&quot;&gt;Counting operations&lt;/h3&gt;

&lt;p&gt;The idea here is that to analyze a solution, you need to have a general idea of how much time (or space) it is taking. Going through the code, you &lt;strong&gt;count all of the operations and assignments&lt;/strong&gt; that are taking place.&lt;/p&gt;

&lt;p&gt;You don’t need the most accurate tally. It’s about noticing general trends. Let’s say your function takes an argument &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;, a number. If you notice that your code often does something &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; times, it will take longer to complete as the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; grows.&lt;/p&gt;

&lt;h3 id=&quot;big-o-notation&quot;&gt;Big O Notation&lt;/h3&gt;

&lt;p&gt;Describes the relationship of the input size of a function, and time it takes to run. It’s about describing overall trends. We are talking about the worst case scenario, or the upper bounds. For example, if you have an input of a large array, and the function is searching that array for a specific item, we have to assume that we need to search the whole array, even if in reality, the item is found earlier.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Time complexity&lt;/strong&gt; is the time it takes an algorithm to run.&lt;/p&gt;

&lt;p&gt;Some examples:&lt;/p&gt;

&lt;p&gt;O(1) is constant - it means that no matter what &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; is, the time will be about the same.&lt;/p&gt;

&lt;p&gt;O(n) is linear - as &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; grows, the time takes longer&lt;/p&gt;

&lt;p&gt;O(n^2) is quadratic - as &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; grows, the time increases exponentially&lt;/p&gt;

&lt;h3 id=&quot;simplifying&quot;&gt;Simplifying&lt;/h3&gt;

&lt;p&gt;Let’s say there are 10 operations that happen in this function, &lt;code class=&quot;highlighter-rouge&quot;&gt;10n&lt;/code&gt;. We don’t need to worry about the 10, and just simplify to &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;. We just care about what happens as the input grows.&lt;/p&gt;

&lt;p&gt;In general, constants don’t matter, and we can get rid of them. It’s about comparing the different algorithms to each other.&lt;/p&gt;

&lt;p&gt;Example: O(n^2 + 5n + 8) simplifies to n^2. This is because if you plug in a large number for &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;, 5n and 8 are tiny in comparison to n^2, so we can ignore them.&lt;/p&gt;

&lt;p&gt;Rule of thumb:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;arthimetic operations are constant&lt;/li&gt;
  &lt;li&gt;variable assignment is constant&lt;/li&gt;
  &lt;li&gt;accessing items in an array by index, or object by key, is constant&lt;/li&gt;
  &lt;li&gt;loops: the complexity is the length of the loop times the complexity of whatever is inside the loop - that’s why we multiply n for nested loops&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Just need to worry about what happens as &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; grows - not what happens when &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; is small.&lt;/p&gt;

&lt;h3 id=&quot;space-complexity&quot;&gt;Space complexity&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Space complexity&lt;/strong&gt; - the space, or memory, required by an algorithm.&lt;/p&gt;

&lt;p&gt;Rules of thumb:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;most primitive, except for strings, are constant space - booleans, numbers, undefined, and null&lt;/li&gt;
  &lt;li&gt;strings are O(n), &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; being the length of the string&lt;/li&gt;
  &lt;li&gt;reference types are also O(n) - for arrays, &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; is the length, and for objects,&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; is the number of keys&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;logarithms&quot;&gt;Logarithms&lt;/h3&gt;

&lt;p&gt;Reminder of how logs work: logs are the inverse of exponentiation.&lt;/p&gt;

&lt;p&gt;They work like this:
&lt;code class=&quot;highlighter-rouge&quot;&gt;log2(value) = exponent =&amp;gt; 2^exponent = value&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Rule of thumb: The logarithm of a number roughly measures the number of times you can divide that number by its base before you get a value that’s less than or equal to one.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;log2(8) = 3

// divide 8 by 2 as many times as you can before geting to 1 (or less)

8 / 2 = 4
4 / 2 = 2
2 / 2 = 1

// it took 3 operations, so the answer is 3.

//Also, 2 to the power of 3 = 8 (2 * 2 * 2)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://www.khanacademy.org/math/algebra2/x2ec2f6f830c9fb89:logs/x2ec2f6f830c9fb89:log-intro/a/intro-to-logarithms&quot;&gt;Here’s a khanacedemy article&lt;/a&gt; explaining logarithms in a beginner friendly way.&lt;/p&gt;

&lt;p&gt;O(log(n)) is one of the best ones you can have, second to constant time. On a graph, it is essentially the opposite of an exponential graph - after an initial increase, the curve flattens out.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="computer-science" />
      
        <category term="data-structures" />
      

      
        <summary type="html">I am learning about data structures and algorithms again.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Binary math - addition problem</title>
      <link href="http://localhost:4000/binary-math" rel="alternate" type="text/html" title="Binary math - addition problem" />
      <published>2023-07-02T22:30:00-06:00</published>
      <updated>2023-07-02T22:30:00-06:00</updated>
      <id>http://localhost:4000/binary-math</id>
      <content type="html" xml:base="http://localhost:4000/binary-math">&lt;p&gt;Lately I’ve been working on some practice coding problems, and I needed to re-learn how to do math with binary numbers.&lt;/p&gt;

&lt;p&gt;The problem was to simply add two binary numbers - the inputs, &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; were strings, and the output needed to be a string as well.&lt;/p&gt;

&lt;p&gt;There are better explantions about binary and math out there, these are just some notes in my own words to help me in the future. Crash Course on youtube has a great series on computer science, and they &lt;a href=&quot;https://www.youtube.com/watch?v=1GSjbWt0c9M&quot;&gt;have an excellent video explaining binary here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;how-binary-works&quot;&gt;How binary works&lt;/h3&gt;

&lt;p&gt;Every day we deal with the decimal number system, which has 10 digits we can work with: 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9. We also call this base 10. Binary has only two digits, 0 and 1. We can call it base 2.&lt;/p&gt;

&lt;p&gt;When we are solving a simple addition problem on paper, we start with the 1’s place, working from right to left. We add the numbers in the 1’s place, and if the sum is 10 or greater, we have to carry a value. We add that value to the numbers in the next column, the 10’s place, and continue from there. Each column increases by a factor of 10, since we are in base 10.&lt;/p&gt;

&lt;p&gt;We can use the same method with the binary system, it’s just the value of each column is different. Since we are in base 2, each column increases by a factor of 2. Instead of 1, 10, 100, 1000… we have, again from right to left, 1, 2, 4, 8, 16, 32, and so on. You add the columns in the same way.&lt;/p&gt;

&lt;h3 id=&quot;adding&quot;&gt;Adding&lt;/h3&gt;

&lt;p&gt;Let’s say you are adding the following binary numbers:&lt;/p&gt;

&lt;p&gt;111
+10&lt;/p&gt;

&lt;p&gt;The right-most column is the 1’s column. 1 + 0 is 1, so your first value is 1. There is nothing to carry.&lt;/p&gt;

&lt;p&gt;Onto the next column, we have 1 and 1. This adds to 2 (10 in binary), so our value we write down is 0 and we carry the 1 to the next column (remember, we only have 0 and 1 to represent our values). Then for our next calculation, we add 1 plus our carried over 1 to get 2 (10 in binary). There are no more columns, so we write down 10.&lt;/p&gt;

&lt;p&gt;This gives us 1001.&lt;/p&gt;

&lt;h3 id=&quot;converting-to-base-10&quot;&gt;Converting to base 10&lt;/h3&gt;

&lt;p&gt;In the example above, our result spans the 8, 4, 2, and 1 columns.&lt;/p&gt;

&lt;p&gt;Because we have a 1 in the 1 column, and a 1 in the 8 column, we can add those together to get a base 10 value of 9.&lt;/p&gt;

&lt;h3 id=&quot;my-initial-solution&quot;&gt;My initial solution&lt;/h3&gt;

&lt;p&gt;I figured I would just loop through each column of the strings I was given, trying to replicate the on-paper addition process. I ended up with this:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//a and b are strings&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//returns a string&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;addBinary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;binaryStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;carryValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;longestStringLength&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;//as many iterations as the length of the longest string - that's how many places our binary number has&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;longestStringLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//iterate over string from right to left - it's highest index to lowest&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;calc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;carryValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//add calc to the beginning of binaryStr, carry value if needed&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;calc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;binaryStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;calc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;binaryStr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;carryValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;calc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;binaryStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;calc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;binaryStr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;carryValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;//account for a carried over value from last opertion, if there is one, otherwise return&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;carryValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;binaryStr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;binaryStr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;a-better-or-shorter-solution&quot;&gt;A better (or shorter) solution&lt;/h3&gt;

&lt;p&gt;I looked at some other solutions and found that JavaScript has prefixes to convert other number systems to base 10. In this case, we add “0b” to the beginning of our strings, convert to numbers, add together, and return a string.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;addBinary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;calc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;BigInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0b&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;BigInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0b&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;calc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BigInt&lt;/code&gt; was used here to handle potential large inputs. Also, to return a string in binary rather than base 10, we add a radix to the &lt;code class=&quot;highlighter-rouge&quot;&gt;toString()&lt;/code&gt; method. 2 means base 2 in this case.&lt;/p&gt;

&lt;h3 id=&quot;prefixes&quot;&gt;Prefixes&lt;/h3&gt;

&lt;p&gt;There are prefixes for other number systems too:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0o&lt;/code&gt; for octal&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x&lt;/code&gt; for hexadecimal&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;e&lt;/code&gt; for exponents&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The letter after the leading zero can be uppercase or lowercase.&lt;/p&gt;

&lt;h3 id=&quot;tostring-radix&quot;&gt;toString() radix&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;toString()&lt;/code&gt;, be definition, returns a string value that represents a number. It is meant to convert a number to a string, so it makes sense that you can convert between different number systems at the same time. Including a radix is optional, and defaults to 10, but it can be any value between 2 and 36.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="binary" />
      
        <category term="computer-science" />
      
        <category term="javascript" />
      
        <category term="coding-problems" />
      

      
        <summary type="html">Lately I’ve been working on some practice coding problems, and I needed to re-learn how to do math with binary numbers.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">What’s the difference between ‘i++’ and ‘++i’</title>
      <link href="http://localhost:4000/increment-decrement" rel="alternate" type="text/html" title="What's the difference between 'i++' and '++i'" />
      <published>2022-10-02T18:30:00-06:00</published>
      <updated>2022-10-02T18:30:00-06:00</updated>
      <id>http://localhost:4000/increment-decrement</id>
      <content type="html" xml:base="http://localhost:4000/increment-decrement">&lt;p&gt;I have always been familiar with incrementing a variable using &lt;code class=&quot;highlighter-rouge&quot;&gt;i++&lt;/code&gt;, but recently came across &lt;code class=&quot;highlighter-rouge&quot;&gt;++i&lt;/code&gt;. It took me a while to truly understand the difference.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;i++&lt;/code&gt; is used as a shorthand for writing &lt;code class=&quot;highlighter-rouge&quot;&gt;i = i + 1&lt;/code&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;++i&lt;/code&gt; does the same. The difference between the two is in what value is returned from this operation.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;returnIncrementPrefix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;returnIncrementPostfix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// returns 6&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In the example above, we use the prefix &lt;code class=&quot;highlighter-rouge&quot;&gt;++i&lt;/code&gt;. When 5 is used as an argument in this function, 6 is returned. Knowing that &lt;code class=&quot;highlighter-rouge&quot;&gt;++i&lt;/code&gt; increments by one, this seems to make sense.&lt;/p&gt;

&lt;p&gt;What happens when we use the postfix?&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;returnIncrementPostfix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;returnIncrementPostfix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// returns 5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The above code returns a value of 5. At first this doesn’t make sense. We are supposed to be incrementing by 1, right? Shouldn’t this also equal 6?&lt;/p&gt;

&lt;p&gt;Nope! In the first example, these steps occur:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;i is incremented by 1, giving i a value of 6&lt;/li&gt;
  &lt;li&gt;i is returned&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We are returned the value of i &lt;em&gt;after&lt;/em&gt; it has been incremented.&lt;/p&gt;

&lt;p&gt;In the second example using the postfix, i is being returned &lt;em&gt;before&lt;/em&gt; it is incremented. The operation doesn’t happen until after 5 has been returned to us.&lt;/p&gt;

&lt;p&gt;It’s all about the order in which the steps occur.&lt;/p&gt;

&lt;h4 id=&quot;tip-for-remembering&quot;&gt;Tip for remembering&lt;/h4&gt;

&lt;p&gt;If you need help remembering which operation does which, think of it this way. If the “++” comes &lt;em&gt;before&lt;/em&gt; the i, incrementation happens before it is returned. If the “++” comes &lt;em&gt;after&lt;/em&gt; the i, the incrementation happens after it is returned.&lt;/p&gt;

&lt;p&gt;Of course, this applies to other operations, including decrementation.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="computer-science" />
      
        <category term="javascript" />
      

      
        <summary type="html">I have always been familiar with incrementing a variable using i++, but recently came across ++i. It took me a while to truly understand the difference.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Learning data structures - advanced structures (trees)</title>
      <link href="http://localhost:4000/data-structures-3" rel="alternate" type="text/html" title="Learning data structures - advanced structures (trees)" />
      <published>2021-07-07T14:30:00-06:00</published>
      <updated>2021-07-07T14:30:00-06:00</updated>
      <id>http://localhost:4000/data-structures-3</id>
      <content type="html" xml:base="http://localhost:4000/data-structures-3">&lt;p&gt;This is the last section of intro to data structures. We are now getting into non-linear data structures.&lt;/p&gt;

&lt;p&gt;Everything up to this point has been a linear structure. The next data structures to cover are trees.&lt;/p&gt;

&lt;p&gt;Once again following along with &lt;a href=&quot;https://www.youtube.com/watch?v=zg9ih6SVACc&amp;amp;t=7744s&quot;&gt;this video&lt;/a&gt; and supplementing with other sources.&lt;/p&gt;

&lt;h3 id=&quot;trees&quot;&gt;Trees&lt;/h3&gt;

&lt;p&gt;Nodes in a tree have a hierarchical relationship. Nodes can point to multiple nodes instead of just one, like we saw in linked lists.&lt;/p&gt;

&lt;p&gt;There are lots of different types of trees, but one important one is called a &lt;strong&gt;binarysearch tree&lt;/strong&gt; .&lt;/p&gt;

&lt;p&gt;Binary search tree:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;some rules:
    &lt;ul&gt;
      &lt;li&gt;nodes can only have 2 children&lt;/li&gt;
      &lt;li&gt;the child to the left of the parent must be less than or equal to the parent while the child to the right must be greater than or equal to the parent&lt;/li&gt;
      &lt;li&gt;nodes cannot have the same value&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;can perform searches on the tree in a logarithmic time&lt;/li&gt;
  &lt;li&gt;at any given node during a search, choose left or right depending on if the value is less than or greater than the value at the current node&lt;/li&gt;
  &lt;li&gt;these are good for storing large amounts of data because they are quick to search - for BigO notation, I believe that makes it O(log n)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Another tree that is used is called a &lt;strong&gt;Trie&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;these store letters of the alphabet&lt;/li&gt;
  &lt;li&gt;to retrieve word based data&lt;/li&gt;
  &lt;li&gt;each node has an array that includes references to letters&lt;/li&gt;
  &lt;li&gt;the nodes basically spell out words as you go down the different paths on the tree&lt;/li&gt;
  &lt;li&gt;the end of a word is marked by a flag - so nodes contain pointers to letters that follow as well as flags for the ends of words&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Heaps:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;parent nodes compare to child nodes and whether they are greater than or less than&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;min-heap:&lt;/strong&gt; root node is the minimum compared to the children&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;max-heap:&lt;/strong&gt; root node is the maximum compared to the children&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Graphs:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;made up of nodes and edges (paths between the nodes)&lt;/li&gt;
  &lt;li&gt;not linear&lt;/li&gt;
  &lt;li&gt;undirected graphs: direction between nodes doesn’t matter&lt;/li&gt;
  &lt;li&gt;directed graph: direction does matter&lt;/li&gt;
  &lt;li&gt;cyclic graph: nodes have a path back to itself (undirected count, since you can go any direction back to the start)&lt;/li&gt;
  &lt;li&gt;acyclic graph: no path from one node back to itself&lt;/li&gt;
  &lt;li&gt;edges can have a weight - kind of like distance between nodes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When to use trees?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;any time you have hierarchical data&lt;/li&gt;
  &lt;li&gt;tries are used by things like spellcheck and autocomplete features&lt;/li&gt;
  &lt;li&gt;heaps used for sorting algorithms like HeapSort, and priority queues&lt;/li&gt;
  &lt;li&gt;graphs: used in shortest path algorithm, social media users, and more&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;That’s it for intro data structures! These posts probably read way more like notes than actual blog posts, but as I am still learning data structures I don’t have much else to share.&lt;/p&gt;

&lt;p&gt;It’s interesting to learn the theory but I kept wondering how I would actually apply this in real projects. Especially in Javascript projects. Do all these data structures exist in Javascript? Do they go by different names? I still have a lot of questions.&lt;/p&gt;

&lt;p&gt;My next step will be to learn about Javascript specific data structures and real life applications.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="computer-science" />
      
        <category term="data-structures" />
      

      
        <summary type="html">This is the last section of intro to data structures. We are now getting into non-linear data structures.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Learning data structures - intermediate structures</title>
      <link href="http://localhost:4000/data-structures-2" rel="alternate" type="text/html" title="Learning data structures - intermediate structures" />
      <published>2021-06-10T14:30:00-06:00</published>
      <updated>2021-06-10T14:30:00-06:00</updated>
      <id>http://localhost:4000/data-structures-2</id>
      <content type="html" xml:base="http://localhost:4000/data-structures-2">&lt;p&gt;Now we are getting into some intermediate topics in data structures.&lt;/p&gt;

&lt;p&gt;Again I am following along with the &lt;a href=&quot;https://www.youtube.com/watch?v=zg9ih6SVACc&amp;amp;t=3551s&quot;&gt;freeCodeCamp video&lt;/a&gt; on data structures as I learn.&lt;/p&gt;

&lt;p&gt;We are now going to be going over sequential access data structures. Unlike random access data structures, you can access items only in a certain order, which means you are depending on other items in the data structure. You can’t get items instantly like you can with arrays.&lt;/p&gt;

&lt;h3 id=&quot;stacks&quot;&gt;Stacks&lt;/h3&gt;

&lt;p&gt;Stacks follow the “last in first out” principle - the last item you add is the first item to be removed.&lt;/p&gt;

&lt;p&gt;The video has a great analogy for this where they envision a stack of books. If you wanted to grab a book from the middle of the stack, you first have to remove all the other books on top, in order, otherwise the whole thing will collapse.&lt;/p&gt;

&lt;p&gt;I also thought of this like a stack of plates. The last one you put on top of the stack is the first one you will use.&lt;/p&gt;

&lt;p&gt;Some stack methods:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;push: adds to top of stack&lt;/li&gt;
  &lt;li&gt;pop: removes from top of stack&lt;/li&gt;
  &lt;li&gt;peek: get the value of the top item, without removing it&lt;/li&gt;
  &lt;li&gt;contains: to find something within the stack&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Interestingly, pop and push are the same names as common Javascript array methods. The contains method reminds me of the Javascript array method “includes”. This is definitely making me think I need to find a Javascript specific data structures resource.&lt;/p&gt;

&lt;p&gt;BigO efficiency:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;accessing, searching: O(n)&lt;/li&gt;
  &lt;li&gt;inserting, deleting: O(1), because you just do push or pop once&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When would you use stacks?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;for recursion - when functions call themselves repeatedly&lt;/li&gt;
  &lt;li&gt;a back button in the browser - add your pages/actions to a stack&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;queues&quot;&gt;Queues&lt;/h3&gt;

&lt;p&gt;Follows a first in first out principle. Just like a line-up in real life. The first person in the line is the first person served.&lt;/p&gt;

&lt;p&gt;Some queue methods:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;enqueue: add to the end/tail of the queue&lt;/li&gt;
  &lt;li&gt;dequeue: remove from the start/head of the queue&lt;/li&gt;
  &lt;li&gt;peek: tells us the value at the head of the queue&lt;/li&gt;
  &lt;li&gt;contains: if our queue contains are specific element&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BigO efficiency:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;accessing, searching: O(n)&lt;/li&gt;
  &lt;li&gt;inserting, deleting: O(1), because you just do enqueue or dequeue once, same as the stack&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I actually use queues fairly often when working with AWS, particularly SQS queues. Events can be added to a queue, and processed by, for example, a Lambda function in the order they are received, when the function is ready for the next one.&lt;/p&gt;

&lt;h3 id=&quot;linked-lists&quot;&gt;Linked lists&lt;/h3&gt;

&lt;p&gt;I was very interested in learning what exactly a linked list is. I hear about them all the time but don’t actually know what they do.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sequential&lt;/li&gt;
  &lt;li&gt;each element is called a node, and a node contains data and a reference to the next node&lt;/li&gt;
  &lt;li&gt;nodes are objects and can have multiple values&lt;/li&gt;
  &lt;li&gt;the reference is what &lt;em&gt;links&lt;/em&gt; the elements together into a list&lt;/li&gt;
  &lt;li&gt;the last node reference points towards a null value&lt;/li&gt;
  &lt;li&gt;can add or remove items anywhere in the list, unlike stacks and queues, but this means you also have to change the references&lt;/li&gt;
  &lt;li&gt;can only go forwards, not backwards&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Linked list methods:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;add to head of list: need to add a reference to the former head node,&lt;/li&gt;
  &lt;li&gt;remove from head: just set reference to null&lt;/li&gt;
  &lt;li&gt;add to middle: reference of new node needs to be to the next item in the list, and the item before must have its reference updated to that of the new node&lt;/li&gt;
  &lt;li&gt;remove from middle: set the reference of the node before to point to the node after the one you’re removing, then update the reference of the one you’re removing to null&lt;/li&gt;
  &lt;li&gt;add to the end: make the tail node point to the new node&lt;/li&gt;
  &lt;li&gt;remove from the end: set the node before the tail node to null&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BigO efficiency:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;accessing, searching: O(n) - still need to go through each node before we get to the one we want, using the pointers to get us there&lt;/li&gt;
  &lt;li&gt;inserting, deleting: can be O(n) or O(1), depending on if you’re adding to the beginning/end or in the middle&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So how are these actually used? In situations where one thing points to another&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;music playlists&lt;/li&gt;
  &lt;li&gt;photo albums&lt;/li&gt;
  &lt;li&gt;can work with queues and stacks behind the scenes&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;doubly-linked-lists&quot;&gt;Doubly linked lists&lt;/h3&gt;

&lt;p&gt;Regular linked lists could only point forwards, but doubly linked lists can point forwards and backwards.&lt;/p&gt;

&lt;p&gt;You don’t just have a pointer to the next node, you also have a pointer to the previous node.&lt;/p&gt;

&lt;p&gt;Like a linked list, there is a head and tail node. The first pointer of the head node points to a null value, as well as the second pointer of the tail node.&lt;/p&gt;

&lt;p&gt;BigO efficiency: the same as for linked lists&lt;/p&gt;

&lt;p&gt;Uses - basically whenever you want to go back and forth between things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;browser caches&lt;/li&gt;
  &lt;li&gt;undo/redo&lt;/li&gt;
  &lt;li&gt;open recent functionality&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dictionaries&quot;&gt;Dictionaries&lt;/h3&gt;

&lt;p&gt;These are also called associated arrays and maps. So in Javascript, a dictionary is referred to as a map (not the same as the map function).&lt;/p&gt;

&lt;p&gt;Dictionaries store data in key-value pairs. Keys can be any primitive data type. Keys must be unique and can only have one value assigned to them. This makes it easier and faster to look up values later. Values do not have to be unique, however.&lt;/p&gt;

&lt;h4 id=&quot;hash-tables&quot;&gt;Hash tables&lt;/h4&gt;

&lt;p&gt;During the lesson on dictionaries the instructor went over hash tables. Yet another term I’ve heard a lot about and never understood.&lt;/p&gt;

&lt;p&gt;Hash tables help you to store keys from a dictionary while cutting down on nil/empty values being taken up in memory. A hash function is what assigns keys to locations in memory so they can be retrieved easily later.&lt;/p&gt;

&lt;p&gt;Dictionaries are built on hash tables.&lt;/p&gt;

&lt;p&gt;Ok, back to dictionaries.&lt;/p&gt;

&lt;p&gt;BigO efficiency: in the case of dictionaries, we can’t just use the worst case scenario, things get pretty complicated due to hash tables.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;for the average efficiency, all operations are O(1). That is because they are key-value pairs, so it’s quick to look up a value based on its key. You don’t have to spend a lot of time searching through your data structure to perform your operation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dictionaries are overall very useful data structures that can be used in many situations.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;That’s it for the intermediate data structures. The deeper I go into all of this, the more I want to find information on how these all apply to Javascript specifically. I’ll finish up the rest of the data structures in this course, and find more information on data structures in Javascript.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="computer-science" />
      
        <category term="data-structures" />
      

      
        <summary type="html">Now we are getting into some intermediate topics in data structures.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Learning data structures - performance and basic structures</title>
      <link href="http://localhost:4000/data-structures" rel="alternate" type="text/html" title="Learning data structures - performance and basic structures" />
      <published>2021-05-23T14:30:00-06:00</published>
      <updated>2021-05-23T14:30:00-06:00</updated>
      <id>http://localhost:4000/data-structures</id>
      <content type="html" xml:base="http://localhost:4000/data-structures">&lt;p&gt;It felt like it was about time to dive deeper into data structures.&lt;/p&gt;

&lt;p&gt;This is one of those topics that I knew I needed to learn in more depth eventually, but didn’t get around to until now. I was working on a difficult programming problem where I had to convert some data from one structure to another for my front end to be able to use it. I was frustrated because I felt like I had a gap in my knowledge - how do I create and work with these data structures efficiently? Through a lot of trial and error I figured it out, but it likely would have been easier if I had more knowledge of the specific structures I was using - in this case, objects and maps in Javascript.&lt;/p&gt;

&lt;h3 id=&quot;what-is-a-data-structure&quot;&gt;What is a data structure?&lt;/h3&gt;

&lt;p&gt;Turns out my idea of data structures as a concept wasn’t too far off - the &lt;a href=&quot;https://www.youtube.com/watch?v=zg9ih6SVACc&amp;amp;list=WL&amp;amp;index=7&quot;&gt;free code camp video I’m using to help me learn&lt;/a&gt; defined a data structure as something that stores data and allows a user to manipulate that data.&lt;/p&gt;

&lt;p&gt;Things you might want to do with a data structure include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;accessing the data&lt;/li&gt;
  &lt;li&gt;searching the data&lt;/li&gt;
  &lt;li&gt;inserting a new item&lt;/li&gt;
  &lt;li&gt;deleting an item&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;big-o-notation&quot;&gt;Big-O Notation&lt;/h3&gt;

&lt;p&gt;This helps us to determine how efficient our data structures are. It measures the complexity of an algorithm.&lt;/p&gt;

&lt;p&gt;I found &lt;a href=&quot;https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation&quot;&gt;this article that helps explain this concept for beginners&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You essentially score a data structure based on how it performs if you increase the size of the data input into your program.&lt;/p&gt;

&lt;p&gt;You give a score to the data structure for how well it can accomplish the tasks mentioned above (access, search, insert, delete). When you are choosing how to store your data, you should choose the data structure that is most efficient at the thing you are mainly using it for.&lt;/p&gt;

&lt;p&gt;Performance of a function is based on the &lt;strong&gt;number of operations&lt;/strong&gt; it takes to complete its task.&lt;/p&gt;

&lt;p&gt;We measure performance by using equations that take in the size of the data set. This equation returns the number of operations. These are called Time Complexity Equations. We don’t actually measure time, however, as that can vary depending on the machine you are using to run your program.&lt;/p&gt;

&lt;h4 id=&quot;most-common-time-complexity-equations-from-highest-to-lowest-efficiency&quot;&gt;Most common Time Complexity Equations, from highest to lowest efficiency&lt;/h4&gt;

&lt;p&gt;n = the size of the data set&lt;/p&gt;

&lt;p&gt;The first three are pretty good:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O(1)&lt;/strong&gt;: the best possible score is 1. This means that the task can be completed with one operation. It always takes the same amount of time regardless of the size of the data set it is working with.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O(log n)&lt;/strong&gt;: still very fast; the larger the data set, the more efficient it is. Follows a logarithmic curve (the inverse of an exponential curve, if like me you don’t remember much about logarithmic curves from school).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;example algorithm that uses this: binary search&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;O(n)&lt;/strong&gt;: the number of operations needed is proportional to the number of items in the data set. This would be represented by a linear graph.&lt;/p&gt;

&lt;p&gt;The next three are not so good:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O(n log n)&lt;/strong&gt;: not quite linear, performance gets slightly worse as the size of the data set increases&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O(n^2) and O(2^n)&lt;/strong&gt;: gets exponentially worse as the size increases&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;n^2 can happen with nested loops&lt;/li&gt;
  &lt;li&gt;you could end up with n^3, n^4 and larger if you have even more code nested with in your nests&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;basic-data-structures---arrays-and-array-lists&quot;&gt;Basic data structures - arrays and array lists&lt;/h3&gt;

&lt;p&gt;Arrays and array lists are random-access data structures. This means you can access any element inside them directly without depending on any of the other elements.&lt;/p&gt;

&lt;h4 id=&quot;arrays&quot;&gt;Arrays&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;can be used to store anything, usually similar values&lt;/li&gt;
  &lt;li&gt;items in an array are called elements&lt;/li&gt;
  &lt;li&gt;indexes are used to identify the elements in the array, starting at index 0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Parallel arrays: multiple arrays have corresponding values, like employees and their salaries&lt;/p&gt;

&lt;p&gt;There was a point when I started to become confused while watching the freeCodeCamp video. They say that an array can store data of only one type. This isn’t true in Javascript, as it is an un-typed language. You can also add and remove items in a Javascript array, so the size is not always fixed; in the video, fixed-size was an important aspect of the array data structure. If my understanding of data storage is correct, this means that you cannot reserve continuous spaces in memory for all your array elements (in Javascript). This could affect how the data is accessed and therefore its performance.&lt;/p&gt;

&lt;p&gt;Moving on…&lt;/p&gt;

&lt;p&gt;You can have two-dimensional arrays:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;at each index of the first array, there is another array&lt;/li&gt;
  &lt;li&gt;looks like a spreadsheet&lt;/li&gt;
  &lt;li&gt;use two indexes to access each item, first for column and second for row&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BigO efficiency for arrays:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;accessing: O(1)&lt;/li&gt;
  &lt;li&gt;searching, deleting, inserting: O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;array-lists&quot;&gt;Array lists&lt;/h4&gt;

&lt;p&gt;This began to clear up my confusion about Javascript arrays and size. An array list has the same properties as an array, except it is dynamic and can grow. Exactly what I’m used to with Javascript. So, in Javascript, is an “array” actually an “array list”? That is something I need to dive into further.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;array lists usually use arrays in the background. Some languages, like Python (and possibly Javascript?) mix properties of arrays and array lists.&lt;/li&gt;
  &lt;li&gt;has built-in methods. Javascript has methods like pop, unshift, and length, to name a few.&lt;/li&gt;
  &lt;li&gt;in memory, array list items are stored as references to other places in memory - the actual element values are stored elsewhere in memory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BigO efficiency for array lists:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;accessing: O(1)&lt;/li&gt;
  &lt;li&gt;searching, inserting, deleting: O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For both arrays and array lists, searching, inserting, and deleting will require us to go through each item to complete the task (you could also find the correct element on the first try, but for BigO notation we look at the worst case scenario).&lt;/p&gt;

&lt;p&gt;Use arrays if:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;you won’t be changing the size or modifying the data&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Otherwise, array lists are more powerful and a better choice. As we can see above, the efficiency in terms of BigO are the same.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;That’s all for the basics. The next posts will get into the intermediate and advanced data structures.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="computer-science" />
      
        <category term="data-structures" />
      

      
        <summary type="html">It felt like it was about time to dive deeper into data structures.</summary>
      

      
      
    </entry>
  
</feed>
