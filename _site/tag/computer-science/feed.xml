<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="https://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="http://localhost:4000/tag/computer-science/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2022-05-16T19:32:44-06:00</updated>
  <id>http://localhost:4000/tag/computer-science/feed.xml</id>

  
  
  

  
    <title type="html">Julia Hack | </title>
  

  
    <subtitle>Web development blog</subtitle>
  

  

  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">Learning data structures - advanced structures (trees)</title>
      <link href="http://localhost:4000/data-structures-3" rel="alternate" type="text/html" title="Learning data structures - advanced structures (trees)" />
      <published>2021-07-07T14:30:00-06:00</published>
      <updated>2021-07-07T14:30:00-06:00</updated>
      <id>http://localhost:4000/data-structures-3</id>
      <content type="html" xml:base="http://localhost:4000/data-structures-3">&lt;p&gt;This is the last section of intro to data structures. We are now getting into non-linear data structures.&lt;/p&gt;

&lt;p&gt;Everything up to this point has been a linear structure. The next data structures to cover are trees.&lt;/p&gt;

&lt;p&gt;Once again following along with &lt;a href=&quot;https://www.youtube.com/watch?v=zg9ih6SVACc&amp;amp;t=7744s&quot;&gt;this video&lt;/a&gt; and supplementing with other sources.&lt;/p&gt;

&lt;h3 id=&quot;trees&quot;&gt;Trees&lt;/h3&gt;

&lt;p&gt;Nodes in a tree have a hierarchical relationship. Nodes can point to multiple nodes instead of just one, like we saw in linked lists.&lt;/p&gt;

&lt;p&gt;There are lots of different types of trees, but one important one is called a &lt;strong&gt;binarysearch tree&lt;/strong&gt; .&lt;/p&gt;

&lt;p&gt;Binary search tree:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;some rules:
    &lt;ul&gt;
      &lt;li&gt;nodes can only have 2 children&lt;/li&gt;
      &lt;li&gt;the child to the left of the parent must be less than or equal to the parent while the child to the right must be greater than or equal to the parent&lt;/li&gt;
      &lt;li&gt;nodes cannot have the same value&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;can perform searches on the tree in a logarithmic time&lt;/li&gt;
  &lt;li&gt;at any given node during a search, choose left or right depending on if the value is less than or greater than the value at the current node&lt;/li&gt;
  &lt;li&gt;these are good for storing large amounts of data because they are quick to search - for BigO notation, I believe that makes it O(log n)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Another tree that is used is called a &lt;strong&gt;Trie&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;these store letters of the alphabet&lt;/li&gt;
  &lt;li&gt;to retrieve word based data&lt;/li&gt;
  &lt;li&gt;each node has an array that includes references to letters&lt;/li&gt;
  &lt;li&gt;the nodes basically spell out words as you go down the different paths on the tree&lt;/li&gt;
  &lt;li&gt;the end of a word is marked by a flag - so nodes contain pointers to letters that follow as well as flags for the ends of words&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Heaps:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;parent nodes compare to child nodes and whether they are greater than or less than&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;min-heap:&lt;/strong&gt; root node is the minimum compared to the children&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;max-heap:&lt;/strong&gt; root node is the maximum compared to the children&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Graphs:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;made up of nodes and edges (paths between the nodes)&lt;/li&gt;
  &lt;li&gt;not linear&lt;/li&gt;
  &lt;li&gt;undirected graphs: direction between nodes doesn’t matter&lt;/li&gt;
  &lt;li&gt;directed graph: direction does matter&lt;/li&gt;
  &lt;li&gt;cyclic graph: nodes have a path back to itself (undirected count, since you can go any direction back to the start)&lt;/li&gt;
  &lt;li&gt;acyclic graph: no path from one node back to itself&lt;/li&gt;
  &lt;li&gt;edges can have a weight - kind of like distance between nodes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When to use trees?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;any time you have hierarchical data&lt;/li&gt;
  &lt;li&gt;tries are used by things like spellcheck and autocomplete features&lt;/li&gt;
  &lt;li&gt;heaps used for sorting algorithms like HeapSort, and priority queues&lt;/li&gt;
  &lt;li&gt;graphs: used in shortest path algorithm, social media users, and more&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;That’s it for intro data structures! These posts probably read way more like notes than actual blog posts, but as I am still learning data structures I don’t have much else to share.&lt;/p&gt;

&lt;p&gt;It’s interesting to learn the theory but I kept wondering how I would actually apply this in real projects. Especially in Javascript projects. Do all these data structures exist in Javascript? Do they go by different names? I still have a lot of questions.&lt;/p&gt;

&lt;p&gt;My next step will be to learn about Javascript specific data structures and real life applications.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="computer-science" />
      
        <category term="data-structures" />
      

      
        <summary type="html">This is the last section of intro to data structures. We are now getting into non-linear data structures.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Learning data structures - intermediate structures</title>
      <link href="http://localhost:4000/data-structures-2" rel="alternate" type="text/html" title="Learning data structures - intermediate structures" />
      <published>2021-06-10T14:30:00-06:00</published>
      <updated>2021-06-10T14:30:00-06:00</updated>
      <id>http://localhost:4000/data-structures-2</id>
      <content type="html" xml:base="http://localhost:4000/data-structures-2">&lt;p&gt;Now we are getting into some intermediate topics in data structures.&lt;/p&gt;

&lt;p&gt;Again I am following along with the &lt;a href=&quot;https://www.youtube.com/watch?v=zg9ih6SVACc&amp;amp;t=3551s&quot;&gt;freeCodeCamp video&lt;/a&gt; on data structures as I learn.&lt;/p&gt;

&lt;p&gt;We are now going to be going over sequential access data structures. Unlike random access data structures, you can access items only in a certain order, which means you are depending on other items in the data structure. You can’t get items instantly like you can with arrays.&lt;/p&gt;

&lt;h3 id=&quot;stacks&quot;&gt;Stacks&lt;/h3&gt;

&lt;p&gt;Stacks follow the “last in first out” principle - the last item you add is the first item to be removed.&lt;/p&gt;

&lt;p&gt;The video has a great analogy for this where they envision a stack of books. If you wanted to grab a book from the middle of the stack, you first have to remove all the other books on top, in order, otherwise the whole thing will collapse.&lt;/p&gt;

&lt;p&gt;I also thought of this like a stack of plates. The last one you put on top of the stack is the first one you will use.&lt;/p&gt;

&lt;p&gt;Some stack methods:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;push: adds to top of stack&lt;/li&gt;
  &lt;li&gt;pop: removes from top of stack&lt;/li&gt;
  &lt;li&gt;peek: get the value of the top item, without removing it&lt;/li&gt;
  &lt;li&gt;contains: to find something within the stack&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Interestingly, pop and push are the same names as common Javascript array methods. The contains method reminds me of the Javascript array method “includes”. This is definitely making me think I need to find a Javascript specific data structures resource.&lt;/p&gt;

&lt;p&gt;BigO efficiency:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;accessing, searching: O(n)&lt;/li&gt;
  &lt;li&gt;inserting, deleting: O(1), because you just do push or pop once&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When would you use stacks?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;for recursion - when functions call themselves repeatedly&lt;/li&gt;
  &lt;li&gt;a back button in the browser - add your pages/actions to a stack&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;queues&quot;&gt;Queues&lt;/h3&gt;

&lt;p&gt;Follows a first in first out principle. Just like a line-up in real life. The first person in the line is the first person served.&lt;/p&gt;

&lt;p&gt;Some queue methods:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;enqueue: add to the end/tail of the queue&lt;/li&gt;
  &lt;li&gt;dequeue: remove from the start/head of the queue&lt;/li&gt;
  &lt;li&gt;peek: tells us the value at the head of the queue&lt;/li&gt;
  &lt;li&gt;contains: if our queue contains are specific element&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BigO efficiency:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;accessing, searching: O(n)&lt;/li&gt;
  &lt;li&gt;inserting, deleting: O(1), because you just do enqueue or dequeue once, same as the stack&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I actually use queues fairly often when working with AWS, particularly SQS queues. Events can be added to a queue, and processed by, for example, a Lambda function in the order they are received, when the function is ready for the next one.&lt;/p&gt;

&lt;h3 id=&quot;linked-lists&quot;&gt;Linked lists&lt;/h3&gt;

&lt;p&gt;I was very interested in learning what exactly a linked list is. I hear about them all the time but don’t actually know what they do.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sequential&lt;/li&gt;
  &lt;li&gt;each element is called a node, and a node contains data and a reference to the next node&lt;/li&gt;
  &lt;li&gt;nodes are objects and can have multiple values&lt;/li&gt;
  &lt;li&gt;the reference is what &lt;em&gt;links&lt;/em&gt; the elements together into a list&lt;/li&gt;
  &lt;li&gt;the last node reference points towards a null value&lt;/li&gt;
  &lt;li&gt;can add or remove items anywhere in the list, unlike stacks and queues, but this means you also have to change the references&lt;/li&gt;
  &lt;li&gt;can only go forwards, not backwards&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Linked list methods:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;add to head of list: need to add a reference to the former head node,&lt;/li&gt;
  &lt;li&gt;remove from head: just set reference to null&lt;/li&gt;
  &lt;li&gt;add to middle: reference of new node needs to be to the next item in the list, and the item before must have its reference updated to that of the new node&lt;/li&gt;
  &lt;li&gt;remove from middle: set the reference of the node before to point to the node after the one you’re removing, then update the reference of the one you’re removing to null&lt;/li&gt;
  &lt;li&gt;add to the end: make the tail node point to the new node&lt;/li&gt;
  &lt;li&gt;remove from the end: set the node before the tail node to null&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BigO efficiency:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;accessing, searching: O(n) - still need to go through each node before we get to the one we want, using the pointers to get us there&lt;/li&gt;
  &lt;li&gt;inserting, deleting: can be O(n) or O(1), depending on if you’re adding to the beginning/end or in the middle&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So how are these actually used? In situations where one thing points to another&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;music playlists&lt;/li&gt;
  &lt;li&gt;photo albums&lt;/li&gt;
  &lt;li&gt;can work with queues and stacks behind the scenes&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;doubly-linked-lists&quot;&gt;Doubly linked lists&lt;/h3&gt;

&lt;p&gt;Regular linked lists could only point forwards, but doubly linked lists can point forwards and backwards.&lt;/p&gt;

&lt;p&gt;You don’t just have a pointer to the next node, you also have a pointer to the previous node.&lt;/p&gt;

&lt;p&gt;Like a linked list, there is a head and tail node. The first pointer of the head node points to a null value, as well as the second pointer of the tail node.&lt;/p&gt;

&lt;p&gt;BigO efficiency: the same as for linked lists&lt;/p&gt;

&lt;p&gt;Uses - basically whenever you want to go back and forth between things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;browser caches&lt;/li&gt;
  &lt;li&gt;undo/redo&lt;/li&gt;
  &lt;li&gt;open recent functionality&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dictionaries&quot;&gt;Dictionaries&lt;/h3&gt;

&lt;p&gt;These are also called associated arrays and maps. So in Javascript, a dictionary is referred to as a map (not the same as the map function).&lt;/p&gt;

&lt;p&gt;Dictionaries store data in key-value pairs. Keys can be any primitive data type. Keys must be unique and can only have one value assigned to them. This makes it easier and faster to look up values later. Values do not have to be unique, however.&lt;/p&gt;

&lt;h4 id=&quot;hash-tables&quot;&gt;Hash tables&lt;/h4&gt;

&lt;p&gt;During the lesson on dictionaries the instructor went over hash tables. Yet another term I’ve heard a lot about and never understood.&lt;/p&gt;

&lt;p&gt;Hash tables help you to store keys from a dictionary while cutting down on nil/empty values being taken up in memory. A hash function is what assigns keys to locations in memory so they can be retrieved easily later.&lt;/p&gt;

&lt;p&gt;Dictionaries are built on hash tables.&lt;/p&gt;

&lt;p&gt;Ok, back to dictionaries.&lt;/p&gt;

&lt;p&gt;BigO efficiency: in the case of dictionaries, we can’t just use the worst case scenario, things get pretty complicated due to hash tables.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;for the average efficiency, all operations are O(1). That is because they are key-value pairs, so it’s quick to look up a value based on its key. You don’t have to spend a lot of time searching through your data structure to perform your operation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dictionaries are overall very useful data structures that can be used in many situations.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;That’s it for the intermediate data structures. The deeper I go into all of this, the more I want to find information on how these all apply to Javascript specifically. I’ll finish up the rest of the data structures in this course, and find more information on data structures in Javascript.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="computer-science" />
      
        <category term="data-structures" />
      

      
        <summary type="html">Now we are getting into some intermediate topics in data structures.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Learning data structures - performance and basic structures</title>
      <link href="http://localhost:4000/data-structures" rel="alternate" type="text/html" title="Learning data structures - performance and basic structures" />
      <published>2021-05-23T14:30:00-06:00</published>
      <updated>2021-05-23T14:30:00-06:00</updated>
      <id>http://localhost:4000/data-structures</id>
      <content type="html" xml:base="http://localhost:4000/data-structures">&lt;p&gt;It felt like it was about time to dive deeper into data structures.&lt;/p&gt;

&lt;p&gt;This is one of those topics that I knew I needed to learn in more depth eventually, but didn’t get around to until now. I was working on a difficult programming problem where I had to convert some data from one structure to another for my front end to be able to use it. I was frustrated because I felt like I had a gap in my knowledge - how do I create and work with these data structures efficiently? Through a lot of trial and error I figured it out, but it likely would have been easier if I had more knowledge of the specific structures I was using - in this case, objects and maps in Javascript.&lt;/p&gt;

&lt;h3 id=&quot;what-is-a-data-structure&quot;&gt;What is a data structure?&lt;/h3&gt;

&lt;p&gt;Turns out my idea of data structures as a concept wasn’t too far off - the &lt;a href=&quot;https://www.youtube.com/watch?v=zg9ih6SVACc&amp;amp;list=WL&amp;amp;index=7&quot;&gt;free code camp video I’m using to help me learn&lt;/a&gt; defined a data structure as something that stores data and allows a user to manipulate that data.&lt;/p&gt;

&lt;p&gt;Things you might want to do with a data structure include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;accessing the data&lt;/li&gt;
  &lt;li&gt;searching the data&lt;/li&gt;
  &lt;li&gt;inserting a new item&lt;/li&gt;
  &lt;li&gt;deleting an item&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;big-o-notation&quot;&gt;Big-O Notation&lt;/h3&gt;

&lt;p&gt;This helps us to determine how efficient our data structures are. It measures the complexity of an algorithm.&lt;/p&gt;

&lt;p&gt;I found &lt;a href=&quot;https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation&quot;&gt;this article that helps explain this concept for beginners&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You essentially score a data structure based on how it performs if you increase the size of the data input into your program.&lt;/p&gt;

&lt;p&gt;You give a score to the data structure for how well it can accomplish the tasks mentioned above (access, search, insert, delete). When you are choosing how to store your data, you should choose the data structure that is most efficient at the thing you are mainly using it for.&lt;/p&gt;

&lt;p&gt;Performance of a function is based on the &lt;strong&gt;number of operations&lt;/strong&gt; it takes to complete its task.&lt;/p&gt;

&lt;p&gt;We measure performance by using equations that take in the size of the data set. This equation returns the number of operations. These are called Time Complexity Equations. We don’t actually measure time, however, as that can vary depending on the machine you are using to run your program.&lt;/p&gt;

&lt;h4 id=&quot;most-common-time-complexity-equations-from-highest-to-lowest-efficiency&quot;&gt;Most common Time Complexity Equations, from highest to lowest efficiency&lt;/h4&gt;

&lt;p&gt;n = the size of the data set&lt;/p&gt;

&lt;p&gt;The first three are pretty good:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O(1)&lt;/strong&gt;: the best possible score is 1. This means that the task can be completed with one operation. It always takes the same amount of time regardless of the size of the data set it is working with.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O(log n)&lt;/strong&gt;: still very fast; the larger the data set, the more efficient it is. Follows a logarithmic curve (the inverse of an exponential curve, if like me you don’t remember much about logarithmic curves from school).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;example algorithm that uses this: binary search&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;O(n)&lt;/strong&gt;: the number of operations needed is proportional to the number of items in the data set. This would be represented by a linear graph.&lt;/p&gt;

&lt;p&gt;The next three are not so good:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O(n log n)&lt;/strong&gt;: not quite linear, performance gets slightly worse as the size of the data set increases&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O(n^2) and O(2^n)&lt;/strong&gt;: gets exponentially worse as the size increases&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;n^2 can happen with nested loops&lt;/li&gt;
  &lt;li&gt;you could end up with n^3, n^4 and larger if you have even more code nested with in your nests&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;basic-data-structures---arrays-and-array-lists&quot;&gt;Basic data structures - arrays and array lists&lt;/h3&gt;

&lt;p&gt;Arrays and array lists are random-access data structures. This means you can access any element inside them directly without depending on any of the other elements.&lt;/p&gt;

&lt;h4 id=&quot;arrays&quot;&gt;Arrays&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;can be used to store anything, usually similar values&lt;/li&gt;
  &lt;li&gt;items in an array are called elements&lt;/li&gt;
  &lt;li&gt;indexes are used to identify the elements in the array, starting at index 0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Parallel arrays: multiple arrays have corresponding values, like employees and their salaries&lt;/p&gt;

&lt;p&gt;There was a point when I started to become confused while watching the freeCodeCamp video. They say that an array can store data of only one type. This isn’t true in Javascript, as it is an un-typed language. You can also add and remove items in a Javascript array, so the size is not always fixed; in the video, fixed-size was an important aspect of the array data structure. If my understanding of data storage is correct, this means that you cannot reserve continuous spaces in memory for all your array elements (in Javascript). This could affect how the data is accessed and therefore its performance.&lt;/p&gt;

&lt;p&gt;Moving on…&lt;/p&gt;

&lt;p&gt;You can have two-dimensional arrays:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;at each index of the first array, there is another array&lt;/li&gt;
  &lt;li&gt;looks like a spreadsheet&lt;/li&gt;
  &lt;li&gt;use two indexes to access each item, first for column and second for row&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BigO efficiency for arrays:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;accessing: O(1)&lt;/li&gt;
  &lt;li&gt;searching, deleting, inserting: O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;array-lists&quot;&gt;Array lists&lt;/h4&gt;

&lt;p&gt;This began to clear up my confusion about Javascript arrays and size. An array list has the same properties as an array, except it is dynamic and can grow. Exactly what I’m used to with Javascript. So, in Javascript, is an “array” actually an “array list”? That is something I need to dive into further.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;array lists usually use arrays in the background. Some languages, like Python (and possibly Javascript?) mix properties of arrays and array lists.&lt;/li&gt;
  &lt;li&gt;has built-in methods. Javascript has methods like pop, unshift, and length, to name a few.&lt;/li&gt;
  &lt;li&gt;in memory, array list items are stored as references to other places in memory - the actual element values are stored elsewhere in memory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BigO efficiency for array lists:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;accessing: O(1)&lt;/li&gt;
  &lt;li&gt;searching, inserting, deleting: O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For both arrays and array lists, searching, inserting, and deleting will require us to go through each item to complete the task (you could also find the correct element on the first try, but for BigO notation we look at the worst case scenario).&lt;/p&gt;

&lt;p&gt;Use arrays if:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;you won’t be changing the size or modifying the data&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Otherwise, array lists are more powerful and a better choice. As we can see above, the efficiency in terms of BigO are the same.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;That’s all for the basics. The next posts will get into the intermediate and advanced data structures.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="computer-science" />
      
        <category term="data-structures" />
      

      
        <summary type="html">It felt like it was about time to dive deeper into data structures.</summary>
      

      
      
    </entry>
  
</feed>
