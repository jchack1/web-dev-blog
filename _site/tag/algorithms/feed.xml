<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="https://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="http://localhost:4000/tag/algorithms/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2023-07-28T19:37:34-06:00</updated>
  <id>http://localhost:4000/tag/algorithms/feed.xml</id>

  
  
  

  
    <title type="html">Julia Hack | </title>
  

  
    <subtitle>Web development blog</subtitle>
  

  

  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">Binary trees; isSameTree problem</title>
      <link href="http://localhost:4000/binary-trees" rel="alternate" type="text/html" title="Binary trees; isSameTree problem" />
      <published>2023-07-28T15:30:00-06:00</published>
      <updated>2023-07-28T15:30:00-06:00</updated>
      <id>http://localhost:4000/binary-trees</id>
      <content type="html" xml:base="http://localhost:4000/binary-trees">&lt;p&gt;It’s time to dive into some binary tree coding problems.&lt;/p&gt;

&lt;p&gt;But I think I need to learn more about binary trees, and how to tackle these kinds of problems first, so I actually have a chance of getting them right.&lt;/p&gt;

&lt;p&gt;Resources:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;This was a quick, &lt;a href=&quot;https://www.youtube.com/watch?v=GzJoqJO1zdI&quot;&gt;helpful video&lt;/a&gt; that summarized binary trees nicely&lt;/li&gt;
  &lt;li&gt;This &lt;a href=&quot;https://www.youtube.com/watch?v=5cU1ILGy6dM&quot;&gt;video from freeCodeCamp&lt;/a&gt; describes how to deal with binary search trees in JavaScript&lt;/li&gt;
  &lt;li&gt;This &lt;a href=&quot;https://www.freecodecamp.org/news/binary-search-tree-traversal-inorder-preorder-post-order-for-bst/&quot;&gt;article from freeCodeCamp&lt;/a&gt; summarizing tree traversal&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;compared-to-other-data-structures---linked-lists&quot;&gt;Compared to other data structures - linked lists&lt;/h3&gt;

&lt;p&gt;Like linked lists, trees are made up of nodes that have data and pointers.&lt;/p&gt;

&lt;p&gt;I’ve delved a bit into singly linked-lists, whose nodes have one pointer. In comparison, trees can have multiple pointers to the next nodes. In the case of a binary tree, a node points towards a maximum of 2 child nodes. Each node can have a &lt;code class=&quot;highlighter-rouge&quot;&gt;left&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;right&lt;/code&gt; pointer, comparable to the &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt; pointer in a linked list.&lt;/p&gt;

&lt;p&gt;The top node of the tree is called the &lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt; node, comparable to the &lt;code class=&quot;highlighter-rouge&quot;&gt;head&lt;/code&gt; node of a linked list. Nodes with no children are called &lt;code class=&quot;highlighter-rouge&quot;&gt;leaf&lt;/code&gt; nodes. The path from the root to a leaf is called a &lt;code class=&quot;highlighter-rouge&quot;&gt;branch&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;traversing-a-binary-tree&quot;&gt;Traversing a binary tree&lt;/h3&gt;

&lt;p&gt;For starters, there are two main approaches to code a tree traversal:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;using a &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; loop and an “on” pointer (like for linked lists, using a “current” pointer with a while loop)&lt;/li&gt;
  &lt;li&gt;recursion&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When you use recursion it’s called branching recursion. Since a node can have multiple children, your stack frame can be branching too.&lt;/p&gt;

&lt;p&gt;Often you need to visit every node in the tree, but how do I know what order to visit in? There are three main types of traversal:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;in-order traversal&lt;/strong&gt;: visit left subtree, then root, then right subtree. Like you’ve moving across the tree from left to right. If you printed out each node as you visted them, they would be in ascending order from left-most to right-most node.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;pre-order traversal&lt;/strong&gt;: visit root, then left subtree, then right subtree. Like you’ve moving from top of tree to bottom (root to leaf). Use if you need to explore the tree from root to leaf, good for making copies of trees.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;post-order traversal&lt;/strong&gt;: visit left subtree, right subtree, then root. Like you’re travelling from the bottom up (leaf to root). Use if you need to explore leaves before roots. Good for deleting a tree.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;coding-problem-issametree-solved-with-recursion&quot;&gt;Coding problem: isSameTree, solved with recursion&lt;/h3&gt;

&lt;p&gt;The first coding problem I worked on to practice binary trees was, given two trees &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;q&lt;/code&gt;, determine if they are the same. If they are the same, they have the same structure AND values at each node.&lt;/p&gt;

&lt;p&gt;I decided to try solving this recursively. Sometimes I still struggle with recursion, due to its nested nature. One thing that helps me is to remember that I should always be returning whatever data type the final result is looking for. In this case, we are looking for a boolean, so my base cases must all return true or false. It’s also helpful to think of recursion as repeating sub-problems. What is the sub-problem you are trying to solve here, over and over again?&lt;/p&gt;

&lt;p&gt;In this case, the sub-problem is checking if the current nodes p and q are equal.&lt;/p&gt;

&lt;p&gt;After checking base cases, you need some logic for checking your next values. That’s where your recursive calls come in. Then, you need to do something with the result of those calls. The outer function could return at this point, or maybe you need to add the result to another data structure you’re keeping track of, like a memo object.&lt;/p&gt;

&lt;p&gt;This is what I came up with, and it submitted to leetcode successfully:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isSameTree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//base cases&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;//continue exploring tree&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;isSameTree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;isSameTree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;First, the base cases:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;both p and q are null: in this case return true, because they are equal, and we have reached a leaf node. This branch has nothing else to explore and if we got this far, it is the same for p and q&lt;/li&gt;
  &lt;li&gt;one of p &lt;strong&gt;or&lt;/strong&gt; q, &lt;strong&gt;not both&lt;/strong&gt;, is null: if one node is null and the other is not, they are not &lt;em&gt;structurally&lt;/em&gt; equal, so return false&lt;/li&gt;
  &lt;li&gt;check if the &lt;strong&gt;values&lt;/strong&gt; of p and q are equal. If not, return false. Otherwise, the nodes so far are equal and there is more tree to explore, so we can move on.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Next step: recursive calls&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;we need explore the left and right subtrees for our p and q nodes. If either of these returns false, it means p and q were not equal.&lt;/li&gt;
  &lt;li&gt;this is where you start to see branching recursion come into play, since you have to check the left and right child of every node.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Finally, if we got through all of that and never encountered unequal structure or values, we can return true.&lt;/p&gt;

&lt;h3 id=&quot;next-steps&quot;&gt;Next steps&lt;/h3&gt;

&lt;p&gt;I definitely need more practice with binary trees, so I’ll continue learning and practicing and will update here if I find anything notable.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="algorithms" />
      
        <category term="data-structures" />
      
        <category term="coding-problems" />
      
        <category term="recursion" />
      

      
        <summary type="html">It’s time to dive into some binary tree coding problems.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Reverse a linked list in JavaScript</title>
      <link href="http://localhost:4000/reverse-linked-list" rel="alternate" type="text/html" title="Reverse a linked list in JavaScript" />
      <published>2023-07-21T15:30:00-06:00</published>
      <updated>2023-07-21T15:30:00-06:00</updated>
      <id>http://localhost:4000/reverse-linked-list</id>
      <content type="html" xml:base="http://localhost:4000/reverse-linked-list">&lt;p&gt;Today’s leetcode problem involved linked lists again. This time the task was to reverse one.&lt;/p&gt;

&lt;p&gt;I honestly had no idea how to do this and had to look it up. Below is the code I ended up with, and an explanation.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;reverseList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;previous&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//because when we start there is no previous&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;//while current node is not null&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//keep track of what our next node is&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//first time through, the new end of our list is null&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;previous&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//our new previous is the one we just looked at&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;previous&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//move on to the next node&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;//previous is now new head&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;previous&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To help me explain, here is a simple diagram of a linked list.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/linkedListDiagram.svg&quot; style=&quot;max-width: 500px;&quot; alt=&quot;diagram of a linked list with three nodes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This code presents an iterative approach to the problem. You could also solve it recursively.&lt;/p&gt;

&lt;p&gt;For this method, you iterate over each node using a &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; loop, and change the pointers for each node.&lt;/p&gt;

&lt;h4 id=&quot;initialize-the-variables&quot;&gt;Initialize the variables&lt;/h4&gt;

&lt;p&gt;To use the while loop, you need to set a &lt;code class=&quot;highlighter-rouge&quot;&gt;current&lt;/code&gt; variable. The loop will run while this is not null, or until we reach the end of the list, which will have no next pointer.&lt;/p&gt;

&lt;p&gt;We also need to keep track of the &lt;code class=&quot;highlighter-rouge&quot;&gt;previous&lt;/code&gt; node in the list, as well as the &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt; one. &lt;code class=&quot;highlighter-rouge&quot;&gt;previous&lt;/code&gt; is set to null at the beginning, since we’re on the first node, and we’ll deal with the &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt; value in the loop&lt;/p&gt;

&lt;h4 id=&quot;setting-next-and-resetting-currents-pointer&quot;&gt;Setting next and resetting current’s pointer&lt;/h4&gt;

&lt;p&gt;It’s crucial to save the &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt; variable first thing during a new iteration. That’s because the following step replaces the pointer for &lt;code class=&quot;highlighter-rouge&quot;&gt;current&lt;/code&gt;, so we lost whatever next used to be.&lt;/p&gt;

&lt;p&gt;Let’s keep track of our variables for the linked list diagram above.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt; now equals node &lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then, update &lt;code class=&quot;highlighter-rouge&quot;&gt;current&lt;/code&gt;’s pointer to &lt;code class=&quot;highlighter-rouge&quot;&gt;previous&lt;/code&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;current.next&lt;/code&gt; now equals &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;resetting-the-variables-for-the-next-iteration&quot;&gt;Resetting the variables for the next iteration&lt;/h4&gt;

&lt;p&gt;For our next iteration, &lt;code class=&quot;highlighter-rouge&quot;&gt;previous&lt;/code&gt; will be whatever node we just updated in this iteration.&lt;/p&gt;

&lt;p&gt;So, &lt;code class=&quot;highlighter-rouge&quot;&gt;previous&lt;/code&gt; now equals the &lt;code class=&quot;highlighter-rouge&quot;&gt;current&lt;/code&gt; node, which in this case is node &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;current&lt;/code&gt; node for our next iteration is what we saved earlier in our &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt; variable, which is &lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;end-of-list&quot;&gt;End of list&lt;/h4&gt;

&lt;p&gt;Once we reach the end, we’ll have &lt;code class=&quot;highlighter-rouge&quot;&gt;previous&lt;/code&gt; equal to our last node, &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;. This is the new head. The pointers have all been reversed, so we return the new head node. It’s the start of the reversed linked list.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="javascript" />
      
        <category term="coding-problems" />
      
        <category term="algorithms" />
      

      
        <summary type="html">Today’s leetcode problem involved linked lists again. This time the task was to reverse one.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Does linked list have a cycle - slow/fast pointer algorithm</title>
      <link href="http://localhost:4000/linked-list-has-cycle" rel="alternate" type="text/html" title="Does linked list have a cycle - slow/fast pointer algorithm" />
      <published>2023-07-19T15:30:00-06:00</published>
      <updated>2023-07-19T15:30:00-06:00</updated>
      <id>http://localhost:4000/linked-list-has-cycle</id>
      <content type="html" xml:base="http://localhost:4000/linked-list-has-cycle">&lt;p&gt;Today’s leetcode problem involved a linked list.&lt;/p&gt;

&lt;p&gt;I understand the basic concept of a linked list, but I have never dealt with them with real code. There is no built-in JavaScript data structure for linked lists, so you need to come up with it yourself.&lt;/p&gt;

&lt;h3 id=&quot;what-is-a-linked-list&quot;&gt;What is a linked list?&lt;/h3&gt;

&lt;p&gt;A linked list is a list of elements (nodes) where each element contains a piece of data and a pointer (reference) to the next element in the list. We need this reference to the next element because linked lists are not stored contiguously in memory.&lt;/p&gt;

&lt;p&gt;You can contrast this with arrays, where each element &lt;em&gt;is&lt;/em&gt; stored sequentially in memory. This is why an array can contain only elements and no other references. In other programming languages, arrays are fixed in size when they are created, but this is not the case in JavaScript, where you can add and remove elements at any time. For other languages, a linked list would be more flexible because new elements can be added and stored anywhere in memory, and they would also be more efficient because they only take up memory for elements in use.&lt;/p&gt;

&lt;p&gt;The first node in a linked list is called the &lt;strong&gt;head&lt;/strong&gt;. Every node will point to the next, until you reach the end of the list, where the next element is &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;. Unless, the list contains a cycle, like in today’s problem.&lt;/p&gt;

&lt;h3 id=&quot;linked-list-cycle-problem&quot;&gt;Linked list cycle problem&lt;/h3&gt;

&lt;p&gt;A &lt;strong&gt;cycle&lt;/strong&gt; occurs when a node points to a previous element in the list, so a node can be reached again. Basically the &lt;strong&gt;tail&lt;/strong&gt; node doesn’t point to &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, but points to a node we’ve already seen.&lt;/p&gt;

&lt;p&gt;Today’s problem was to determine whether or not a linked list has a cycle.&lt;/p&gt;

&lt;p&gt;Not seeing any algorithms for linked lists before, I figured I could iterate through the list and if I didn’t find a pointer equal to &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, then there was a cycle. Or, thinking the pointer would be like an array-like numerical index, I could keep a count of the nodes I had already iterated through, and assume we had a cycle if the pointer was a value less than the count.&lt;/p&gt;

&lt;p&gt;Neither of those worked. I became a bit frustrated because I wasn’t sure what the leetcode input actually looked like. I tried to console log it and got nothing, but their input looked to me like an array, which was confusing, and probably why I thought I could just iterate through it.&lt;/p&gt;

&lt;p&gt;I started to look in the discussion and saw many users working with slow and fast pointers.&lt;/p&gt;

&lt;h3 id=&quot;slow-and-fast-pointers&quot;&gt;Slow and fast pointers&lt;/h3&gt;

&lt;p&gt;Also called the Hare and Tortoise or Floyd’s algorithm.&lt;/p&gt;

&lt;p&gt;You traverse the linked list using two pointers at once. You start both pointers on the head node. The “slow” pointer will go through the list one node at a time, while the “fast” pointer will go through the list two nodes at a time. If there is a cycle, there will be a point in time where the slow and fast pointers have landed on the same node - the faster one will have looped back around and met up with the slow one.&lt;/p&gt;

&lt;p&gt;I really liked &lt;a href=&quot;https://medium.com/@dev.adrishs/linked-list-cycle-in-javascript-leetcode-141-142-54c2177c600a&quot;&gt;this explanation&lt;/a&gt; with the tortoise and hare diagram.&lt;/p&gt;

&lt;p&gt;You can check if this is the case by checking if the slow and fast pointers are equal to each other.&lt;/p&gt;

&lt;p&gt;If there is no cycle, the pointers will never get the chance to meet up.&lt;/p&gt;

&lt;h3 id=&quot;the-code&quot;&gt;The code&lt;/h3&gt;

&lt;p&gt;Leetcode has their own way of inputting a linked list data structure into JavaScript questions. I could never get a visual in the console, but it is essentially an object that looks something like this:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c1&quot;&gt;// example from the above linked medium article&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;
                &lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
                    &lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can’t iterate over this with a for loop, so these problems often use while loops and your fast and slow pointers are defined outside of it.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * @param {ListNode} head
 * @return {boolean}
 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hasCycle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;slow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fast&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fast&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;slow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;slow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;fast&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;slow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Start off by making &lt;code class=&quot;highlighter-rouge&quot;&gt;slow&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;fast&lt;/code&gt; equal to the &lt;code class=&quot;highlighter-rouge&quot;&gt;head&lt;/code&gt; node. They are starting off in the same place.&lt;/p&gt;

&lt;p&gt;While your &lt;code class=&quot;highlighter-rouge&quot;&gt;fast&lt;/code&gt; pointer exists and its &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt; pointer is not null, you can move your pointers forward.&lt;/p&gt;

&lt;p&gt;Then you can check if they are equal to the same node. If they are, you have a cycle, and can return true.&lt;/p&gt;

&lt;p&gt;At any point you end up with &lt;code class=&quot;highlighter-rouge&quot;&gt;fast&lt;/code&gt; or its &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt; pointer being null, it means you’ve reached the end of the list, and there is no cycle, so you can return false.&lt;/p&gt;

&lt;h3 id=&quot;a-different-solution&quot;&gt;A different solution&lt;/h3&gt;

&lt;p&gt;Another solution I came across used a &lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt; to store all values we traversed. If your current node matched a node already in the set, you have a cycle, as you’ve seen it before.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hasCycle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nextNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;nextNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;has&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;nextNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;nextNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;nextNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nextNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This logic makes a little more sense in my brain, but it seems like you could potentially use a lot of memory if you added nearly every node to your set. This solution put me in the bottom % of memory usage in leetcode. It seems like the slow/fast algorithm is the way to go.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="javascript" />
      
        <category term="coding-problems" />
      
        <category term="algorithms" />
      

      
        <summary type="html">Today’s leetcode problem involved a linked list.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Algorithms: Boyer-Moore</title>
      <link href="http://localhost:4000/boyer-moore" rel="alternate" type="text/html" title="Algorithms: Boyer-Moore" />
      <published>2023-07-07T22:30:00-06:00</published>
      <updated>2023-07-07T22:30:00-06:00</updated>
      <id>http://localhost:4000/boyer-moore</id>
      <content type="html" xml:base="http://localhost:4000/boyer-moore">&lt;p&gt;Today I learned about a new algorithm while working on a leetcode coding problem.&lt;/p&gt;

&lt;p&gt;The problem was to find the majority element in an array of numbers (&lt;code class=&quot;highlighter-rouge&quot;&gt;nums&lt;/code&gt;) of length &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; - meaning, return the element that appears half the time or more (&lt;code class=&quot;highlighter-rouge&quot;&gt;n / 2&lt;/code&gt;). Your input is guaranteed to have a majority element.&lt;/p&gt;

&lt;h3 id=&quot;my-first-attempt&quot;&gt;My first attempt&lt;/h3&gt;

&lt;p&gt;I figured I could loop through all the elements of the &lt;code class=&quot;highlighter-rouge&quot;&gt;nums&lt;/code&gt; array, and for each one, filter the array to contain elements equal to the current value. If the length of the filtered array is the same or more than the majority (&lt;code class=&quot;highlighter-rouge&quot;&gt;n / 2&lt;/code&gt;), return that element.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * @param {number[]} nums
 * @return {number}
 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;majorityElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;justNum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;justNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This worked for most of the test cases, but with a very long array, I got a timeout error.&lt;/p&gt;

&lt;h3 id=&quot;the-solution&quot;&gt;The solution&lt;/h3&gt;

&lt;p&gt;I looked at some of the comments in the discussion, and they mentioned that this problem related to the Moore’s voting algorithm (or Boyer Moore algorithm).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://iq.opengenus.org/boyer-moore-majority-vote-algorithm/&quot;&gt;I looked it up&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Usually you perform two passes over your elements. During your first pass you:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;initialize a variable for your &lt;code class=&quot;highlighter-rouge&quot;&gt;element&lt;/code&gt;, and another for &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt;. Set &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt; to 0&lt;/li&gt;
  &lt;li&gt;for each element &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;, do the following checks&lt;/li&gt;
  &lt;li&gt;if &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt; = 0, assign &lt;code class=&quot;highlighter-rouge&quot;&gt;element = x&lt;/code&gt; and increment &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt; by 1&lt;/li&gt;
  &lt;li&gt;else if: if &lt;code class=&quot;highlighter-rouge&quot;&gt;element&lt;/code&gt; = x, increment &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;else: decrement &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt; by 1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;element&lt;/code&gt; value you are left with should occur the most often out of all elements.&lt;/p&gt;

&lt;p&gt;Then you would do a second pass over your elements, to check if &lt;code class=&quot;highlighter-rouge&quot;&gt;element&lt;/code&gt; in fact makes up the majority of your elements:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;initialize a variable for &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt;, set to 0&lt;/li&gt;
  &lt;li&gt;for each element, increment &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt; if it is the same as the &lt;code class=&quot;highlighter-rouge&quot;&gt;element&lt;/code&gt; from earlier&lt;/li&gt;
  &lt;li&gt;if in the end, &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt; is greater than or equal to &lt;code class=&quot;highlighter-rouge&quot;&gt;n/2&lt;/code&gt;, this is the majority element&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;my-final-solution&quot;&gt;My final solution&lt;/h3&gt;

&lt;p&gt;I figured I only needed the first pass for my solution, because we were guaranteed a majority element. The second pass only confirmed we had one, so it was not necessary in this case. This time it passed all tests.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * @param {number[]} nums
 * @return {number}
 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;majorityElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="coding-problems" />
      
        <category term="algorithms" />
      

      
        <summary type="html">Today I learned about a new algorithm while working on a leetcode coding problem.</summary>
      

      
      
    </entry>
  
</feed>
