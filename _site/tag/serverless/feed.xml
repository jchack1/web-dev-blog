<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="https://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="http://localhost:4000/tag/serverless/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2023-11-21T17:56:54-07:00</updated>
  <id>http://localhost:4000/tag/serverless/feed.xml</id>

  
  
  

  
    <title type="html">Julia Hack | </title>
  

  
    <subtitle>Web development blog</subtitle>
  

  

  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">Developing a chat app using AWS AppSync</title>
      <link href="http://localhost:4000/appsync-chat-app" rel="alternate" type="text/html" title="Developing a chat app using AWS AppSync" />
      <published>2023-11-21T16:30:00-07:00</published>
      <updated>2023-11-21T16:30:00-07:00</updated>
      <id>http://localhost:4000/appsync-chat-app</id>
      <content type="html" xml:base="http://localhost:4000/appsync-chat-app">&lt;p&gt;I recently created a chat app at work using AWS AppSync, and then decided to re-create it on my own time.&lt;/p&gt;

&lt;p&gt;There were some new features rolled out in AppSync since I started my work project, so I wanted to try them out. It also gave me the opportunity to learn more about setting up authentication with Amplify and Cognito, which I had never tackled before, as authentication had been set up at work by another developer.&lt;/p&gt;

&lt;p&gt;Everything below has also been included on my portfolio site.&lt;/p&gt;

&lt;h3 id=&quot;why-i-chose-to-use-appsync&quot;&gt;Why I chose to use AppSync&lt;/h3&gt;

&lt;p&gt;To create a chat app you need to ensure messages appear on the screen in real time. There needs to be a bi-directional relationship between the front-end and database, and the front-end must display messages immediately upon their creation without refreshing the page. One option for this could have been to use Apollo Client WebSocket Link.&lt;/p&gt;

&lt;p&gt;I attempted this with my original work project. The front-end set-up was simple, but I quickly realized that setting up a web-socket on a serverless app built with AWS Lambda would be challenging. This required manual set-up of the web-socket, creating a new connection each time a user logged in, and storing the connection information in the database. It was much simpler to use AppSync, which removed all of this manual work.&lt;/p&gt;

&lt;h3 id=&quot;the-nitty-gritty-of-my-appsync-experience&quot;&gt;The nitty-gritty of my AppSync experience&lt;/h3&gt;

&lt;p&gt;AppSync allows you to create a GraphQL API that connects to your backend datasources. Resolvers are the functions in your API that handle incoming requests. For my projects, resolvers generally will receive a request, get something from or put something into a DynamoDB database, and return some data to the front-end. A few times I used Lambda functions, connected to DynamoDB, as my datasource, which I will elaborate on later.&lt;/p&gt;

&lt;p&gt;AppSync initially used VTL (Velocity Template Language), which is a Java-based language, to write mapping template code (basically equivalent to resolvers). When I began the original project, AWS just began to roll out JavaScript-based resolvers in a limited capacity. Since it was such a new functionality, and all the AppSync tutorials by my favorite devs on social media were using VTL, I decided to use VTL as well. It was time consuming for me to learn, and debugging in AppSync was often difficult, but eventually I figured it out and delivered a working app to my team.&lt;/p&gt;

&lt;p&gt;When it came time for me to create my own project, JavaScript could be used with any type of resolver. I assumed this would make my life easier and coding this project would be faster. This was not the case. JavaScript is not run on a browser or Node.js runtime, but on a special &lt;code class=&quot;highlighter-rouge&quot;&gt;APPSYNC_JS&lt;/code&gt; runtime, and there are limits on what JavaScript features may be used. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;try/catch&lt;/code&gt; statements are not supported, making error handling challenging; you need to use their built-in functions. &lt;code class=&quot;highlighter-rouge&quot;&gt;async/await&lt;/code&gt; and promises are also not supported. While I understand the logic behind this - awaiting promises is too time-consuming and your AppSync API is supposed to be fast - this presented challenges for my multi-step code.&lt;/p&gt;

&lt;p&gt;Pipeline resolvers are made for this scenario. This could have worked, except there were some cases when I needed to query multiple items from the database using a global secondary index (GSI). There is a built-in AppSync function called &lt;code class=&quot;highlighter-rouge&quot;&gt;BatchGet&lt;/code&gt; which I tried to use, however it will only allow you to get items using the primary key, no secondary indexes, so it didn’t work for me.&lt;/p&gt;

&lt;p&gt;At this point I could have re-worked my data structures, but instead I put my JavaScript code into Lambda functions and used them as the datasource. I was able to use the JavaScript functionality I was familiar with and write the exact DynamoDB queries I needed. For my purposes this worked fine, and I never noticed any performance issues.&lt;/p&gt;

&lt;h3 id=&quot;take-aways-and-future-updates&quot;&gt;Take-aways and future updates&lt;/h3&gt;

&lt;p&gt;Overall I enjoyed learning AppSync. It’s a big time-saver to not have to manually set up web-sockets. Writing the resolvers was the most challenging aspect, since there seemed to be a lot of restrictions on what could be included in your code. I often received errors that said “there is a problem with the code” but nothing more, so debugging was difficult.&lt;/p&gt;

&lt;p&gt;Working with GraphQL is a great experience since it helps me think of my code in terms of inputs and outputs, and it always makes me want to work more with types, specifically using TypeScript. I would have written the backend for this chat app in TypeScript, but I struggled with importing my own types into the code. Again, I got the “there is a problem with the code” error, so it wasn’t clear what exactly the problem was.&lt;/p&gt;

&lt;p&gt;It seems as if AppSync wants you to use it to auto-generate all your types, schemas, and datasources, when I want to write it all myself. In the future I’d like to revisit this; I’d like to see if the developers make this process easier, or dive deeper into the docs to find out if I missed any key details for TypeScript implementation. Perhaps in this environment of AI and cloud services, I need to better embrace the ability of these kinds of services to auto-generate my code and infrastructure for me, if I want to produce software quickly.&lt;/p&gt;

&lt;h3 id=&quot;helpful-resources&quot;&gt;Helpful resources&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mavi888/web-client-appsync-test/tree/master&quot;&gt;Foobar Serverless github repo and accompanying youtube video&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/sid88in/serverless-appsync-plugin/tree/master/doc&quot;&gt;serverless-appsync-plugin docs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/appsync/latest/devguide/what-is-appsync.html&quot;&gt;AWS AppSync developer guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="aws" />
      
        <category term="serverless" />
      
        <category term="appsync" />
      

      
        <summary type="html">I recently created a chat app at work using AWS AppSync, and then decided to re-create it on my own time.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Debugging serverless: ‘AWSLambdaFullAccess does not exist’</title>
      <link href="http://localhost:4000/lambda-fullaccess-bug" rel="alternate" type="text/html" title="Debugging serverless: 'AWSLambdaFullAccess does not exist'" />
      <published>2022-08-30T18:30:00-06:00</published>
      <updated>2022-08-30T18:30:00-06:00</updated>
      <id>http://localhost:4000/lambda-fullaccess-bug</id>
      <content type="html" xml:base="http://localhost:4000/lambda-fullaccess-bug">&lt;p&gt;I don’t write down the solutions to bugs often enough, so here is how I solved a serverless bug today.&lt;/p&gt;

&lt;p&gt;Maintenance tasks are never quite as simple as they appear at first glance. Last year I updated all our lambda functions at work from Node 12 (and lower) to Node 14 - or so I thought. It turns out there were a few I missed, mostly in projects that are not worked on often.&lt;/p&gt;

&lt;p&gt;A year is a long time to not deploy a serverless app into AWS. I updated the runtime to Node 14, and attempted to deploy. There were several errors, one after the other, that I managed to fix. The last error I received had me stuck for a while.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; CREATE_FAILED: CodeDeployServiceRole (AWS::IAM::Role) Policy arn:aws:iam::aws:policy/AWSLambdaFullAccess does not exist or is not attachable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;While there was some CodeDeploy code in the app, there was never any line of code where we explicitly set “AWSLambdaFullAccess”. I tried commenting out the CodeDeploy code under the IAM role section:&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Effect&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Allow&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;Action&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;codedeploy:*&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;Resource&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;*&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But that didn’t do anything.&lt;/p&gt;

&lt;p&gt;After some googling, I saw that the AWSLambdaFullAccess policy had been deprecated, and AWSLambda_FullAccess was its replacement. I vaguely remembered seeing this in an AWS email sometime in the past year. The problem must be connected to this, somehow.&lt;/p&gt;

&lt;p&gt;I checked the serverless-generated cloudformation files in my .serverless folder. There was code for the creation of a AWSLambdaFullAccess policy. But none of our own code was telling it to do that. I thought maybe I had an old version of serverless, but I recently updated my local environment to version 3, and my serverless.yml file didn’t specify a framework version, so that couldn’t be it.&lt;/p&gt;

&lt;p&gt;After lots of trial and error, and more googling, I went back to a &lt;a href=&quot;https://github.com/serverless/components/issues/918&quot;&gt;github issues page&lt;/a&gt; where someone else reported the same issue. At first glace I didn’t see a solution for my problem, but I scrolled a little further and found something helpful.&lt;/p&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;One commenter said their issue was that they had an old version of a plugin “serverless-plugin-canary-deployments”. We had that plugin, too. I thought I had checked the plugin versions and found they were the same across our different microservices, and these microservices never gave the same error. Regardless, I updated that npm package to the latest version and deployed. This time it worked!&lt;/p&gt;

&lt;p&gt;It’s possible to receive this same error and have an entirely different issue causing the problem, but this worked for me. Perhaps we can generalize this and say that if you are getting an error related to a deprecation, have a look at the versions of your dependencies.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="debugging" />
      
        <category term="aws" />
      
        <category term="serverless" />
      

      
        <summary type="html">I don’t write down the solutions to bugs often enough, so here is how I solved a serverless bug today.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Debugging serverless - Eventbridge rule already exists</title>
      <link href="http://localhost:4000/serverless-event-bug" rel="alternate" type="text/html" title="Debugging serverless - Eventbridge rule already exists" />
      <published>2022-01-31T18:30:00-07:00</published>
      <updated>2022-01-31T18:30:00-07:00</updated>
      <id>http://localhost:4000/serverless-event-bug</id>
      <content type="html" xml:base="http://localhost:4000/serverless-event-bug">&lt;p&gt;I recently came across a bug while deploying a serverless microservice using github actions. I may have seen this error before at some point, but I never wrote down the solution, so here is how I solved it this time.&lt;/p&gt;

&lt;p&gt;This is the error message, with the real function and service names changed:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;CREATE_FAILED: AccountsqadeleteAccountrule1EventBridgeRule (AWS::Events::Rule)
myservice-events-qa|accounts-qa-deleteAccount-rule-1 already exists&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This is a message from Cloudformation telling us that our resource, in this case an event rule, couldn’t be created.&lt;/p&gt;

&lt;p&gt;The strange part is that I only encountered this issue when I deployed to an AWS account via github actions (to my QA account), not when I deployed to my dev account from my local machine. There had to be a difference between my dev and QA environments.&lt;/p&gt;

&lt;p&gt;This also only happened with services that had Lambda functions triggered by Eventbridge. Makes sense given that the error message has to do with event rules, though sometimes there can be other explanations for these kinds of problems.&lt;/p&gt;

&lt;h3 id=&quot;problem-solving&quot;&gt;Problem solving&lt;/h3&gt;

&lt;p&gt;One of the steps involved in github actions deployment is to install serverless on the virtual machine github uses to deploy. The logs told me the environment looked like this:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; linux, node 12.22.9, framework 3.0.1, plugin 6.0.0, SDK 4.3.0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Notice “framework: 3.0.1”. I remembered that my local serverless version was still at version 2, and I had not updated it since originally installing it. I confirmed my local version was 2.60.0.&lt;/p&gt;

&lt;p&gt;Maybe there were some breaking changes since the new version came out. But when did version 3 even come out? If it’s a recent change, maybe that’s the cause of my problems.&lt;/p&gt;

&lt;p&gt;I did a quick search and found out that version 3 came out a day or two before I started getting my error. In fact, there was &lt;a href=&quot;https://www.serverless.com/blog/serverless-framework-v3-is-live&quot;&gt;an article from January 27th&lt;/a&gt; about the release of version 3, saying it is now live.&lt;/p&gt;

&lt;p&gt;To be sure this was the problem, I checked the last successful deployment of one of my problem services from a few days earlier, and during the build process serverless@2.72.2 was installed.&lt;/p&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;The solution to this specific Eventbridge problem was just a few lines of code in my serverless.yml file:&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;provider&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;eventBridge&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;useCloudFormation&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is because Eventbridge resources will now be deployed using native Cloudformation instead of Lambda, &lt;a href=&quot;https://www.serverless.com/framework/docs/deprecations#aws-eventbridge-lambda-event-triggers&quot;&gt;which you can read about here&lt;/a&gt;. The solution above won’t work forever, so I’ll need to do some maintenance on all our serverless projects to bring them up-to-date.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="aws" />
      
        <category term="debugging" />
      
        <category term="serverless" />
      

      
        <summary type="html">I recently came across a bug while deploying a serverless microservice using github actions. I may have seen this error before at some point, but I never wrote down the solution, so here is how I solved it this time.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">AWS Lambda</title>
      <link href="http://localhost:4000/lambda" rel="alternate" type="text/html" title="AWS Lambda" />
      <published>2021-04-11T14:30:00-06:00</published>
      <updated>2021-04-11T14:30:00-06:00</updated>
      <id>http://localhost:4000/lambda</id>
      <content type="html" xml:base="http://localhost:4000/lambda">&lt;p&gt;AWS Lambda is huge for me at work. Our app architecture is primarily based on Lambda and the Serverless model.&lt;/p&gt;

&lt;p&gt;There are so many options to choose from when setting up your sevices with AWS. Until now in my Udemy course, a lot of what we have seen involves some sort of servers. A lot of time was spent talking about EC2s, which is basically a computer/server in the cloud that runs your apps.&lt;/p&gt;

&lt;p&gt;Apps created with Lambda don’t run on EC2. This is where “serverless” comes into play. Lambda functions are just functions, small pieces of code that have some purpose. You essentially deploy your lambda functions into AWS and everything is taken care of for you. Your functions can be “connected” by SNS, Eventbridge, SQS, etc (rather than having lambdas calling lambdas).&lt;/p&gt;

&lt;p&gt;We’ll go into more detail below. Once again I am taking notes from my Udemy course - “Ultimate AWS Certified Developer Associate 2021”.&lt;/p&gt;

&lt;h3 id=&quot;serverless&quot;&gt;Serverless&lt;/h3&gt;

&lt;p&gt;You only deploy your code/functions - you no longer have to manage and think about your servers.&lt;/p&gt;

&lt;p&gt;A typical serverless architecture in AWS could include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;users log in with Cognito&lt;/li&gt;
  &lt;li&gt;static site comes from S3&lt;/li&gt;
  &lt;li&gt;API Gateway accesses your Lambda functions, which access your DynamoDB database&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lambda&quot;&gt;Lambda&lt;/h3&gt;

&lt;p&gt;There is a time limit for your functions, up to 15 minutes. Lambda functions are run on demand, only invoked when you need them. They are scaled up automatically by AWS, so more functions are created when you need them. You only pay for invocations and compute time.&lt;/p&gt;

&lt;p&gt;This is different from EC2, which need to be running at all times, and provisioned by you to scale up or down in response to changes in traffic.&lt;/p&gt;

&lt;p&gt;API Gateway works well with Lambda - you create your REST API and the endpoints call your lambdas.&lt;/p&gt;

&lt;p&gt;When you invoke your function, you will get a new log stream in Cloudwatch. You can use Cloudwatch to help debug your functions.&lt;/p&gt;

&lt;h3 id=&quot;synchronous-invocation&quot;&gt;Synchronous invocation&lt;/h3&gt;

&lt;p&gt;You invoke the function, and you wait for the result. This can happen when you use API Gateway, the AWS SDK, or other services.&lt;/p&gt;

&lt;p&gt;Example: client calls API Gateway, which sends the request to Lambda. Lambda will run and return a response to the client through API Gateway. You wait for the response from the Lambda function.&lt;/p&gt;

&lt;h3 id=&quot;lambdas-and-albs-application-load-balancers&quot;&gt;Lambdas and ALBs (Application Load Balancers)&lt;/h3&gt;

&lt;p&gt;Another way, aside from API Gateway, to expose a lambda function via an HTTP endpoint. I first learned about ALBs through their use with EC2, but they can be used with lambdas as well.&lt;/p&gt;

&lt;p&gt;Lambda is registered to a target group. The HTTP request that is sent to the load balancer is converted to a JSON format. Once the lambda code runs, it should return a JSON object, which is converted to HTTP and sent back to the client to indicate the response.&lt;/p&gt;

&lt;p&gt;In a severless.yml file, you could set up ALBs with Lambdas like below, using an ALB event. This code is from &lt;a href=&quot;https://www.serverless.com/framework/docs/providers/aws/events/alb/&quot;&gt;serverless.com&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;functions&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;albEventConsumer&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;handler.hello&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;alb&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;listenerArn&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;arn:aws:elasticloadbalancing:us-east-1:12345:listener/app/my-load-balancer/50dc6c495c0c9188/&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;1&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;conditions&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/hello&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;asynchronous-invocations&quot;&gt;Asynchronous invocations&lt;/h3&gt;

&lt;p&gt;Events placed into event queue, lambda processes events. If there are problems processing, there are up to 3 retries. You can end up with your events processed multiple times. If processing continues to fail you can send the messages to a dead letter queue in SNS or SQS.&lt;/p&gt;

&lt;p&gt;S3, SNS, EventBridge, SES, CloudFormation all use asynchronous invocations.&lt;/p&gt;

&lt;p&gt;This can also be useful if you need to increase processing speed, and order/duplicates aren’t a big deal.&lt;/p&gt;

&lt;h3 id=&quot;eventbridge-and-lambda&quot;&gt;EventBridge and Lambda&lt;/h3&gt;

&lt;p&gt;2 ways to trigger lambda from EventBridge rule:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Set up CRON or Rate EventBridge rule (scheduled) - trigger lambda on a schedule, like every hour&lt;/li&gt;
  &lt;li&gt;Set up CodePipeline EventBridge Rule - trigger lambda whenever the state of the CodePipeline changes&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Note: it wasn’t mentioned in the course, but at work we have services emitting EventBridge events that trigger our lambdas.&lt;/p&gt;

&lt;h3 id=&quot;iam-roles--permissions&quot;&gt;IAM Roles / permissions&lt;/h3&gt;

&lt;p&gt;When lambda functions are &lt;em&gt;invoking other services&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Lambda functions need IAM roles attached to them so they have access to the AWS services they require. This is called an &lt;strong&gt;execution role&lt;/strong&gt;. You should have one execution role per lambda function.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When lambdas are &lt;em&gt;being&lt;/em&gt; accessed by another service:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;give other services access to your lambdas by using a &lt;strong&gt;resource based policy&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://www.serverless.com/blog/abcs-of-iam-permissions&quot;&gt;This link&lt;/a&gt; to serverless.com goes over how to work with IAM roles in serverless.&lt;/p&gt;

&lt;h3 id=&quot;environment-variables&quot;&gt;Environment variables&lt;/h3&gt;

&lt;p&gt;You can add and change environment variables in the Lambda console, but I tend to work with them only in the code.&lt;/p&gt;

&lt;p&gt;In serverless.yml files, variables look like this:&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;variableA&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;${variableSource}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;#also can have a default&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;variableB&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;${variableSource, default}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;#example, with a &quot;dev&quot; stage being the default&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;STAGE&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;${opt:stage, 'dev'}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;networking&quot;&gt;Networking&lt;/h3&gt;

&lt;p&gt;By default, lambdas are launched in the AWS VPC, not your VPC, so they can’t access resources in your VPC. They can access other AWS services and external websites.&lt;/p&gt;

&lt;p&gt;You can launch them inside your VPC, though, and you need to set up the VPC ID, subnets, security groups, and an IAM role. You can deploy a lambda inside a private subnet with a NAT gateway if you want it to access the internet. Interestingly, putting it inside a &lt;em&gt;public&lt;/em&gt; subnet does not give it internet access, so you must use a private subnet.&lt;/p&gt;

&lt;h3 id=&quot;cloudformation&quot;&gt;Cloudformation&lt;/h3&gt;

&lt;p&gt;What I didn’t realize until now was that lambda function code is actually stored in S3. This isn’t something that you have to tell serverless to do explicitly - it is generated by serverless behind the scenes. If you look at the cloudformation templates that are generated by serverless, you will find references to S3 buckets in the code for your lambda functions.&lt;/p&gt;

&lt;p&gt;It looks something like this:&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Properties&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Code&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;S3Bucket&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Ref&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ServerlessDeploymentBucket&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Under “Code” you could also write your code directly, but this is only good for very simple functions, and I honestly wouldn’t consider doing it. Instead you should just reference the S3 bucket where your code is stored.&lt;/p&gt;

&lt;p&gt;Here I can see just how useful serverless is. I don’t have to think about any of these things. In my serverless.yml file all I need to do is reference the handler that my lambda should correspond to with a file path.&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# here, my code is being kept in a folder called &quot;src&quot;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# this is all that's needed - serverless creates all other resources for me&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;createTeam&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;src/teams/teams.createTeam&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In my course, in the Lambda/Cloudformation demo, the instructor is having to go into S3 in the AWS console and create a bucket. Then he needs to reference it in the cloudformation file.&lt;/p&gt;

&lt;p&gt;If you were to do this, you should enable versioning on your bucket (so new versions of your code are updated properly when deployed).&lt;/p&gt;

&lt;p&gt;Once your bucket is created, you upload your code, then go to the cloudformation console and upload your template. There is some config that needs to happen at this step.&lt;/p&gt;

&lt;p&gt;Definitely prefer serverless.yml files, uploaded from my machine, over this process.&lt;/p&gt;

&lt;h3 id=&quot;other-notes&quot;&gt;Other notes&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Lambda can have up to 1000 concurrent executions at once. Lambdas scale up or down automatically. Important: this applies to all lambda functions across your account, not just one application, so you may want to set limits on your functions so one application doesn’t take up all your lambda resources.&lt;/li&gt;
  &lt;li&gt;when connecting to databases / creating other clients like the AWS SDK, it is best practice to initialize them outside of your handler functions at the top of your file. This makes them available for other functions, not just the current one.&lt;/li&gt;
  &lt;li&gt;Lambda layers: split up your function code and put reusable things like large libraries into separate layers - don’t have to be reuploaded every time you change your code, and other functions could use them as well.&lt;/li&gt;
  &lt;li&gt;can create different versions of your lambdas as well - your latest version is mutable, what you’re currently working on. Each version is immutable and can’t be changed once deployed
    &lt;ul&gt;
      &lt;li&gt;an alias is mutable and points to the latest version of your lambda&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="aws" />
      
        <category term="serverless" />
      

      
        <summary type="html">AWS Lambda is huge for me at work. Our app architecture is primarily based on Lambda and the Serverless model.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Deploying simple React app with Serverless / AWS</title>
      <link href="http://localhost:4000/deploy-react-serverless-aws" rel="alternate" type="text/html" title="Deploying simple React app with Serverless / AWS " />
      <published>2020-10-29T18:30:00-06:00</published>
      <updated>2020-10-29T18:30:00-06:00</updated>
      <id>http://localhost:4000/deploy-react-serverless-aws</id>
      <content type="html" xml:base="http://localhost:4000/deploy-react-serverless-aws">&lt;p&gt;I am learning Serverless and AWS for work. Here is what I did to deploy a basic app with Serverless.&lt;/p&gt;

&lt;p&gt;This is assuming you already have an AWS account, and have installed Serverless, the AWS SDK, and set up your AWS credentials on your machine.Simply put, though:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;To install Serverless I ran this command: &lt;code class=&quot;highlighter-rouge&quot;&gt;npm i serverless -g&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;To install the AWS SDK I ran this command: &lt;code class=&quot;highlighter-rouge&quot;&gt;npm i aws-sdk -g&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Once you’ve set up an AWS account you can set up a new user in IAM, and save your credentials on your machine. &lt;a href=&quot;https://www.youtube.com/watch?v=w-OHgML58eg&amp;amp;t=1s&quot;&gt;This video shows that set-up&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this case I already had a project made, which I set up using &lt;code class=&quot;highlighter-rouge&quot;&gt;create-react-app&lt;/code&gt;. You can also set up a new serverless app by creating a new folder and running &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless create --template aws-nodejs&lt;/code&gt;. This is assuming you are using Node.js in the backend. There are many different runtimes you can use and templates available. You can also run &lt;code class=&quot;highlighter-rouge&quot;&gt;create-react-app&lt;/code&gt; after creating your serverless template. The order you do this doesn’t seem to matter, as long as you have all the files you need.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.serverless.com/framework/docs/providers/aws/guide/services/&quot;&gt;This article from Serverless explains services, and all associated files, very well&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To deploy static pages to an S3 bucket on AWS, I installed serverless-finch in my project using &lt;code class=&quot;highlighter-rouge&quot;&gt;npm i --save-dev serverless-finch&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When deploying a React app it is important to run the command &lt;code class=&quot;highlighter-rouge&quot;&gt;npm run build&lt;/code&gt;, so you get a build folder in your project directory. This is where all your static files end up including your index.html, which S3 needs to find in order to deploy your site.&lt;/p&gt;

&lt;h3 id=&quot;inside-the-serverlessyml-file&quot;&gt;Inside the serverless.yml file&lt;/h3&gt;

&lt;p&gt;Setting up a new serverless app will give you a handler file (in my case, handler.js), a .gitignore, and a serverless.yml file. serverless.yml is where you configure your service. Serverless uses this file to work with AWS to deploy your app.&lt;/p&gt;

&lt;p&gt;The following is what I have in my serverless.yml file:&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;react-practice&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;provider&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;aws&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;stage&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;${opt:stage, 'dev'}&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;runtime&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nodejs12.x&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;region&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;us-west-2&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;functions&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;handler.hello&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#    The following are a few example events you can configure&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#    NOTE: Please make sure to change your handler code to work with those events&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#    Check the event documentation for details&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;hello&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;get&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;plugins&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;serverless-finch&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;custom&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;bucketName&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;julia-practice-react1&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;distributionFolder&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/build&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;errorDocument&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;index.html&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;“service” essentially means project. It’s where you define all your functions, resources, events, plugins, and so on. Here you give the service a name.&lt;/p&gt;

&lt;p&gt;Under “provider” is where you specify that you are using AWS and configure your runtime, region, stage, etc. Stage refers to stage of development which includes development, QA, or production. Here the “dev” stage is default, if you don’t specify a stage when you deploy.&lt;/p&gt;

&lt;p&gt;Under each function you can have events. These are events that trigger the function to execute. In this example, and HTTP “get” request is triggering the “hello” function to execute.&lt;/p&gt;

&lt;p&gt;If you have a “resources” section, these are the resources that your functions use when they execute. These could include database tables.&lt;/p&gt;

&lt;p&gt;Note that under “plugins” I added “serverless-finch”.&lt;/p&gt;

&lt;p&gt;Under “custom” and “client” we configure S3.&lt;/p&gt;

&lt;p&gt;bucketName the bucket where S3 will place our files. It must be a globally unique name, meaning no one else in the world have have a bucket with this name.&lt;/p&gt;

&lt;p&gt;distributionFolder is where S3 should look for our files. For React we use “/build”, since that’s where our index.html is.&lt;/p&gt;

&lt;p&gt;S3 also requires you have an errorDocument specified. Since this is just a simple app I didn’t make one and just left it as index.html.&lt;/p&gt;

&lt;h4 id=&quot;what-serverless-does-with-the-serverlessyml-file&quot;&gt;What Serverless does with the serverless.yml file&lt;/h4&gt;

&lt;p&gt;Serverless takes the serverless.yml file and translates it into an AWS CloudFormation template.&lt;/p&gt;

&lt;p&gt;CloudFormation is an AWS service that allows you to manage all your AWS services/resources. You would write a template describing everything you want, and CloudFormation configures it for you.&lt;/p&gt;

&lt;p&gt;This sounds like an improvement over configuring everything yourself in the AWS management console, though these files can still get pretty long and take time to create. That’s where Serverless comes in. Serverless takes your serverless.yml file and creates CloudFormation templates for you.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.serverless.com/framework/docs/providers/aws/guide/deploying/&quot;&gt;Here’s an article describing deployment with Serverless&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;deployment&quot;&gt;Deployment&lt;/h3&gt;

&lt;p&gt;Note: you can set up different commands in the “scripts” section of your package.json file.&lt;/p&gt;

&lt;p&gt;For backend stuff, especially for Lambda functions, run &lt;code class=&quot;highlighter-rouge&quot;&gt;sls deploy --aws-profile={whatever name you set up in your aws credentials file}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;To deploy the client side, into your S3 bucket, run this command &lt;code class=&quot;highlighter-rouge&quot;&gt;sls client deploy --aws-profile={whatever name you set up in your aws credentials file}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Your screen should look something like this if successful. You will see a link you can go to and view the site.
&lt;img src=&quot;../assets/images/sls-cli.jpg&quot; style=&quot;max-width: 500px;&quot; alt=&quot;serverless cli successful&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;errors&quot;&gt;Errors&lt;/h3&gt;

&lt;p&gt;I got an error reading “Serverless Error: Access Denied”. This seemed strange because I never got this error for the backend deploy, so I thought it must have to do with S3. I fixed this by making my bucket public, but I don’t think this is very secure so I need to look into this further.&lt;/p&gt;

&lt;p&gt;Another error said that I was not in the correct region. This was because my bucket and my serverless.yml file “region” did not match. I just had to quickly update my .yml file and there error was solved. I could now see my site.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="react" />
      
        <category term="aws" />
      
        <category term="serverless" />
      

      
        <summary type="html">I am learning Serverless and AWS for work. Here is what I did to deploy a basic app with Serverless.</summary>
      

      
      
    </entry>
  
</feed>
